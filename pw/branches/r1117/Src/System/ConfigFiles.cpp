#include "stdafx.h"

#include "ConfigFiles.h"
#include "Commands.h"
#include "FileSystem/FilePath.h"
#include "FileSystem/FileUtils.h"
#include "FileSystem/FileStream.h"
#include "StrProc.h"
#include "ProfileManager.h"

static NGlobal::CmdListManager  clManager;


namespace NGlobal
{


static bool ReadFile( string *pszBuffer, const string &szFileName )
{
  pszBuffer->clear();
  CObj<FileStream> pStream = new FileStream( szFileName, FILEACCESS_READ, FILEOPEN_OPEN_EXISTING );
  if ( !IsValid( pStream ) || !pStream->IsOk() )
    return false;

  pszBuffer->resize( pStream->GetSize() );
  pStream->Read( const_cast<char *>(pszBuffer->c_str()), pStream->GetSize() );
  return true;
}


void StripBlockCommentsFromConfig(string& szBuffer)
{
  size_t beginPos = 0, endPos;
  while (true)
  {
    beginPos = szBuffer.find("/*", beginPos);
    if (beginPos != string::npos)
    {
      bool secondSlash = szBuffer[beginPos+2] == '/';
      bool leadingSlash = szBuffer[beginPos-1] == '/';

      if(secondSlash && leadingSlash)
      {
        szBuffer.erase(beginPos-1, 4);
        continue;
      }
      else if(secondSlash)
      {
        szBuffer.erase(beginPos, 3);
      }
      else if(leadingSlash)
      {
        szBuffer.erase(beginPos-1, 3);
        continue;
      }

      endPos = szBuffer.find("*/", beginPos);
      if (endPos != string::npos)
        szBuffer.erase(beginPos, (endPos + 2) - beginPos);
      else
        break;
    }
    else
      break;
  }
}


vector<wstring> LoadConfig( const string &szFileName, const NProfile::EProfileFolder folder )
{
  vector<wstring> wcommands;

  string fullPath = NProfile::GetFullFilePath( szFileName, folder );
  if ( !NFile::DoesFileExist( fullPath ) )
  {
    systemLog( NLogg::LEVEL_MESSAGE ) << "Cannot read configuration file \"" << fullPath << "\"" << endl;
    return wcommands;
  }

  string szBuffer;
  if ( !ReadFile( &szBuffer, fullPath ) )
  {
    systemLog( NLogg::LEVEL_MESSAGE ) << "Cannot read configuration file \"" << fullPath << "\"" << endl;
    return wcommands;
  }

  systemLog( NLogg::LEVEL_MESSAGE ) << "Executing \"" << szFileName << "\"" << endl;

  StripBlockCommentsFromConfig(szBuffer);

  vector<string> commands;
  NStr::SplitString( szBuffer.c_str(), &commands, '\n' );
  for ( vector<string>::const_iterator it = commands.begin(); it != commands.end(); ++it )
  {
    if ( it->empty() )
      continue;

    string szCommand( *it );
    NStr::TrimBoth( szCommand, "\n\r" );
    if ( szCommand.substr( 0, 1 ).compare( ";" ) == 0 || szCommand.substr( 0, 2 ).compare( "//" ) == 0 )
      continue;

    wstring wszCommand;
    NStr::ToUnicode( &wszCommand, szCommand );
    wcommands.push_back(wszCommand);
  }

  return wcommands;
}

void SaveConfig( const string &szFileName, EStorageClass storage, const wstring& configContext )
{
  vector<VariantVariable> variables;
  GetVarsByStorage( &variables, storage );

  NFile::CreatePath( NFile::GetFilePath( szFileName ) );

  FILE *pFile = NULL;
#ifdef WIN32	
  if ( fopen_s( &pFile, szFileName.c_str(), "w" ) != 0 )
#else
  if ( (pFile = fopen( szFileName.c_str(), "w" )) != 0 )
#endif

    pFile = NULL;

  if ( pFile == NULL )
  {
    systemLog( NLogg::LEVEL_ASSERT ) << "Can't open " << szFileName << endl;
    return;
  }

  fprintf( pFile, "//============================================================================\n" );
  fprintf( pFile, "// generated by the game, please do not modify\n" );
  fprintf( pFile, "//============================================================================\n" );
  for ( vector<VariantVariable>::const_iterator it = variables.begin(); it != variables.end(); it++ )
  {
    // put global var with spaces in quotes before save
    const wstring &wszValue = it->GetValue().GetString();
    const string szValue = wszValue.find( ' ' ) == wstring::npos ? NStr::ToMBCS( wszValue ) : '\"' + NStr::ToMBCS( wszValue ) + '\"';

    fprintf( pFile, "setvar %s = %s\n", it->GetName().c_str(), szValue.c_str() );
  }

  fclose( pFile );
}

///////////////////////////////////////////////////////////////////////////////

bool ExecuteConfig( const string &szFileName, const NProfile::EProfileFolder folder, const wstring& configContext )
{
  return CmdListManager::Instance()->CreateAndExecute(szFileName, folder, configContext);
}

///////////////////////////////////////////////////////////////////////////////

wstring ContextNameFromFileName( const string &fileName )
{
  return NStr::ToUnicode(NFile::GetFileTitle(fileName)); 
}

///////////////////////////////////////////////////////////////////////////////

void CmdList::Execute()
{
  for (; curCommand < commands.size(); ++curCommand)
  {
    if (!RunCommand(commands[curCommand], context.GetName()))
    {
      break;
    }
  }
}

///////////////////////////////////////////////////////////////////////////////

CmdListManager::~CmdListManager()
{
  for (list<CmdList*>::iterator it = cmdLists.begin(); it != cmdLists.end(); ++it )
  {
    delete (*it);
  }
}

///////////////////////////////////////////////////////////////////////////////

CmdListManager *CmdListManager::Instance()
{
  return &clManager;
}

///////////////////////////////////////////////////////////////////////////////

void CmdListManager::ExecuteList(list<CmdList*>::iterator &it)
{
  (*it)->Execute();

  if ((*it)->Finished())
  {
    delete (*it);
    cmdLists.erase(it);
  }
}


bool CmdListManager::CreateAndExecute( const string &configFileName, const NProfile::EProfileFolder folder, const wstring& ctx )
{
  CmdList *l = new CmdList( configFileName, folder, ctx );
  bool bOK = (l->GetNumCommands() > 0);

  cmdLists.push_back(l);
  ExecuteList(--cmdLists.end());

  return bOK;
}



void CmdListManager::Step()
{
  // continue execution for all command lists
  for (list<CmdList*>::iterator it = cmdLists.begin(); it != cmdLists.end(); )
  {
    list<CmdList*>::iterator next = it; ++next;
    ExecuteList(it);
    it = next;
  }
}


} //namespace NGlobal



static bool CommandExec( const char *name, const vector<wstring> &params ) 
{
  if ( params.size() < 1 || params.size() > 2 )
  {
    systemLog( NLogg::LEVEL_MESSAGE ) << "usage: " << name << " <name> [<folder>]" << endl;		
    return true;
  }

  const string fileName = NStr::ToMBCS( params[0] );
  const wstring ctx = NGlobal::ContextNameFromFileName(fileName);

  if ( params.size() == 2 )
  {
    NProfile::EProfileFolder folder;

    if ( NStr::GetLower( params[1] ).compare( L"global" ) == 0 )
      folder = NProfile::FOLDER_GLOBAL;
    else if ( NStr::GetLower( params[1] ).compare( L"user" ) == 0 )
      folder = NProfile::FOLDER_USER;
    else if ( NStr::GetLower( params[1] ).compare( L"player" ) == 0 )
      folder = NProfile::FOLDER_PLAYER;
    else
    {
      systemLog( NLogg::LEVEL_MESSAGE ) << "RunCommand_exec():: Unknown folder type!" << endl;		
      return true;
    }

    NGlobal::ExecuteConfig( fileName, folder, ctx );
    return true;
  }
  // search file in all folders
  if ( NGlobal::ExecuteConfig( fileName, NProfile::FOLDER_GLOBAL, ctx ) )
    return true;
  if ( NGlobal::ExecuteConfig( fileName, NProfile::FOLDER_USER, ctx ) )
    return true;
  if ( NGlobal::ExecuteConfig( fileName, NProfile::FOLDER_PLAYER, ctx ) )
    return true;

  systemLog( NLogg::LEVEL_MESSAGE ) << "RunCommand_exec():: Cannot find file " << fileName << "!" << endl;		
  return true;
}

REGISTER_CMD( exec, CommandExec )
