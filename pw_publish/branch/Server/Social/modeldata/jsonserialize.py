# -*- coding: utf-8 -*-

#!/usr/bin/env python
# autogenerated file

import sys, os, collections, types

from baseclasses import *
from collects import *
from ref import *
sys.path.append('..') 
sys.path.append('../base')
from base.helpers import *
import GuildBankInfo


class JSONSerialization(object):
    
    SIMPLE_TYPES = (int, long, float, bool, basestring)
    OUR_TYPES = ()
    SERIALIZABLE_CLASSES = {}  
    OUR_TYPES_DICT = {}

    def __init__( self, modeldata ):
        self.modeldata = modeldata
        self.forClient = True
        
        self._decodeMethods = dict(
            Set = self.opt_fromSet,
            Collection = self.opt_fromCollection,
            Ref = self.opt_fromRef,
            SimpleList = self.opt_fromSimpleList,
            SimpleDict = self.opt_fromSimpleDict,
            Talent = self.opt_fromTalent,
            TalentSet = self.opt_fromTalentSet
        )

    def setMode( self, forClient ):
        self.forClient = forClient

    # ---------------------------------------------------------------------------------------------------------------------------------
    # ---------------------------------------------------------------------------------------------------------------------------------
    # DAN: slight optimization (30%)
        
    def isSerializableClass2( self, value ):
        classes = tuple( self.SERIALIZABLE_CLASSES.values() )
        return isinstance( value, classes )
        
        
    def setTypedValue( self, obj, key, val ):
        obj_dict = obj.__dict__
        val_class = val.__class__
        if (key in obj_dict) and (val_class != obj_dict[key].__class__):
            ##self._non_matching_class += 1 #########################            
            obj_class = obj_dict[key].__class__
            if (obj_class == Ref and val_class == int):
                ##self._Refs += 1 #########################
                # Ref -> int: RefType
                obj_dict[key] = Ref( modeldata = self.modeldata )
                obj_dict[key].object = int(val)
            elif obj_class is types.NoneType:
                ##self._obj_Nones += 1 #########################
                ##self._objNoneCounts.inc(key)
                # замену None на осмысленное значение допускаем
                obj_dict[key] = val
            elif (val_class is unicode) and (obj_class in [basestring, str]):
                obj_dict[key] = val.encode( 'utf8' )
            elif val_class is not types.NoneType:
                # всё кроме None пробуем преобразовать к нужному типу
                ##self._conversion_class += 1 #########################
                try:
                    obj_dict[key] = obj_class( val )
                except:
                    error_string = "serial value type mismatch!\nKey %r class is: %r, saved: %r" % (key, obj_class.__name__, val.__class__.__name__)
                    warn( error_string ) 
            ##else:
                ##self._val_Nones += 1 #########################

        else:
            ##self._matching_class += 1 #########################
            obj_dict[key] = val
            
        
    #~ def setTypedValue_OLD( self, obj, key, val ):
        #~ if (key in obj.__dict__) and (val.__class__.__name__ != obj.__dict__[key].__class__.__name__):
            #~ ## в use-case [http://devjira.nivalnetwork.com/browse/PF-32112] про None ничего не говорится
            #~ ## if (obj.__dict__[key] is None):
                #~ ## # замену None на осмысленное значение допускаем, хотя и ругаемся?
                #~ ## warn( error_string )
            
            #~ ## в use-case [http://devjira.nivalnetwork.com/browse/PF-32112] про None ничего не говорится
            #~ if (obj.__dict__[key] is None):
                #~ # замену None на осмысленное значение допускаем
                #~ obj.__dict__[key] = val
            
            #~ elif isinstance(val, basestring) and isinstance(obj.__dict__[key], basestring):
                #~ # замену str <-> unicode допускаем
                #~ obj.__dict__[key] = val
                
            #~ elif (val.__class__ == int) and (obj.__dict__[key].__class__ == float):
                #~ obj.__dict__[key] = float(val)
            
            #~ elif (val.__class__ == int and obj.__dict__[key].__class__ == Ref):
                #~ # Ref -> int: RefType
                #~ obj.__dict__[key] = Ref( modeldata = self.modeldata )
                #~ obj.__dict__[key].object = int(val)
                    
            #~ elif (val.__class__ == float) and (obj.__dict__[key].__class__ == int):
                #~ # float->int: ругаемся и заменяем с обрезанием значения
                #~ error_string = "serial value type mismatch!\nKey %r class is: %r, saved: %r" % (key, obj.__dict__[key].__class__.__name__, val.__class__.__name__)
                #~ warn( error_string ) 
                #~ obj.__dict__[key] = int(val)
                
            #~ elif isinstance(val, basestring) and (obj.__dict__[key].__class__ in [int, long, float]):
                #~ # string-><numeric type>: пытаемся сделать конвертацию, если получилось, ругаемся и заменяем, если нет - ставим default value и ругаемся
                #~ error_string = "serial value type mismatch!\nKey %r class is: %r, saved: %r" % (key, obj.__dict__[key].__class__.__name__, val.__class__.__name__)
                #~ warn( error_string ) 
                #~ try:
                    #~ obj.__dict__[key] = obj.__dict__[key].__class__( val )
                #~ except:
                    #~ pass
                    
            #~ elif val.__class__ in [int, long, float] and isinstance(obj.__dict__[key], basestring):
                #~ # <numeric type> -> string: ругаемся и заменяем
                #~ error_string = "serial value type mismatch!\nKey %r class is: %r, saved: %r" % (key, obj.__dict__[key].__class__.__name__, val.__class__.__name__)
                #~ warn( error_string )
                #~ obj.__dict__[key] = val
                
            #~ else:
                #~ # в остальных случаях _не_трогаем_  и ругаемся
                #~ error_string = "FATAL serial value type mismatch!\nKey %r class is: %r, saved: %r" % (key, obj.__dict__[key].__class__.__name__, val.__class__.__name__)
                #~ warn( error_string ) 
                
            #~ ## raise ValueError( error_string ) -- фатальных ошибок больше не поднимаем; но и значение не присваиваем (рассчитываем на default)
        #~ else:
            #~ obj.__dict__[key] = val
                

    #~ def decodeFromDict2( self, cls, vals ):
        #~ elif cls is Keeper:
            #~ obj = cls( modeldata = self.modeldata )
            #~ for key, val in vals.iteritems():
                #~ obj.add( int(key), val )
        #~ elif cls is Set:
            #~ obj = cls( modeldata = self.modeldata )
            #~ for key, val in vals.iteritems():
                #~ obj.dictionary[int(key)] = int(val)
        #~ elif cls is Ref:
            #~ obj = cls( modeldata = self.modeldata )
            #~ if isinstance(vals, dict):                
                #~ for key, val in vals.iteritems():
                    #~ obj.load_set( key )
            #~ else:
                #~ obj.load_set( vals )
        #~ elif cls is SimpleList:
            #~ obj = cls( modeldata = self.modeldata )
            #~ for val in vals:
                #~ obj.list.append(val)
        #~ elif cls is Collection:
            #~ obj = cls( modeldata = self.modeldata )
            #~ for key, id in vals.iteritems():
                #~ obj.dictionary[int(key)] = int(id)
                #~ obj.reverse[int(id)] = int(key)
        #~ else:
        #~ return obj
        
    #~ def fromJSON2( self, obj_dict ):
        #~ if len(obj_dict) == 1:
            #~ key = obj_dict.keys()[0]
            #~ #key, value = getFirstPair( obj_dict )
            #~ cls = self.SERIALIZABLE_CLASSES.get( key )
            #~ if cls:
                #~ return self.decodeFromDict2(cls, obj_dict[key])
        #~ return obj_dict
        
        
    #---------------------------------------------------------------------
    #---------------------------------------------------------------------
    def opt_fromKeeper( self, dct ):
        # сюда приходит словарь вида { key: obj_val, ... }
        # вернуть нужно словарь вида { key: obj }, collects.Keeper создавать не надо (все равно в ModelData инстанс keeper уже создан)
        dictionary = {}
        
        method = self.opt_recurseFromClass
        for key,subdict in dct.iteritems():
            dictionary[ int(key) ] = method( subdict )
        return dictionary       
        
    #---------------------------------------------------------------------
    def opt_fromSet( self, dct ):
        obj = Set( self.modeldata )
        # сюда приходит словарь { key: id }
        for key,val in dct.iteritems():
            obj.dictionary[ int(key) ] = val
        return obj
        
    #---------------------------------------------------------------------
    def opt_fromCollection( self, dct ):
        ##warn("opt_fromCollection: dct %s" % dct )
        obj = Collection( self.modeldata )
        # сюда приходит словарь { key: id }
        for key,id in dct.iteritems():
            int_key = int(key)
            ##warn( "opt_fromCollection: int_key %s, id %s" % (int_key, id) )
            obj.dictionary[ int_key ] = id
            obj.reverse[ id ] = int_key
        return obj
        
    #---------------------------------------------------------------------
    def opt_fromRef( self, vals ):
        obj = Ref( self.modeldata )
        if isinstance(vals, dict):                
            for key, val in vals.iteritems():
                obj.load_set( key )
        else:
            obj.load_set( vals )
        return obj
            
    #---------------------------------------------------------------------
    def opt_fromSimpleList( self, vals ):
        obj = SimpleList( self.modeldata )
        for val in vals:
            obj.list.append(val)
        return obj

    def opt_fromSimpleDict( self, vals ):
        obj = SimpleDict( self.modeldata )

        #for key, id in vals.iteritems():
        #    k = key2int(key)
        #    obj.dictionary[k] = id
        obj.dictionary.update(vals)
        return obj

    def fromSimpleDictForTalentSet( self, vals ):
        obj = SimpleDict( self.modeldata )
        for key, id in vals.iteritems():
            k = key2int(key)
            obj.dictionary[k] = id
        return obj

    def opt_fromTalentSet(self, dct):
        path = str( dct.get("path", "") )
        id = int( dct.get("id", 0) )
        md = self.modeldata
        hk = md.HeroesKeeper
        gbik = md.GuildBankInfoKeeper
        TalentSetClass = self.SERIALIZABLE_CLASSES.get("TalentSet")
        obj = TalentSetClass( md, id, path )
        obj_dict = obj.__dict__
        obj_dict["refCounter"] = int( dct.get("refCounter", 0) ) # в любом случае будем добавляться в TalentSet

        obj_dict["IsActiveTalentSet"] = bool( dct.get("IsActiveTalentSet", False) )
        obj_dict["TalentSetCrc"] = int( dct.get("TalentSetCrc", 0) )
        obj_dict["Force"] = float( dct.get("Force", 0) )
        obj_dict["TalentSetName"] = utf8convert( dct.get("TalentSetName", "") )
        obj_dict["Stats"] = self.opt_recurseFromClass(dct.get("Stats", None))
        obj_dict["GuildStats"] = self.opt_recurseFromClass(dct.get("GuildStats", None))
        smplDict = dct.get("Talents", {"SimpleDict":{}})
        obj_dict["Talents"] = self.fromSimpleDictForTalentSet(smplDict.get("SimpleDict",{}))
        actBarDict = dct.get("ActionBar", {"SimpleDict":{}})
        obj_dict["ActionBar"] = self.fromSimpleDictForTalentSet(actBarDict.get("SimpleDict",{}))
        instCastDict = dct.get("InstaCast", {"SimpleDict":{}})
        obj_dict["InstaCast"] = self.fromSimpleDictForTalentSet(instCastDict.get("SimpleDict",{}))
        return obj
    #---------------------------------------------------------------------
    def opt_fromTalent( self, dct ):
        path = str( dct.get("path", "") )
        id = int( dct.get("id", 0) )
        md = self.modeldata
        hk = md.HeroesKeeper
        gbik = md.GuildBankInfoKeeper

        TalentClass = self.SERIALIZABLE_CLASSES.get("Talent")
        ##obj = TalentClass( self.modeldata )
        obj = TalentClass( md, id, path )
        obj_dict = obj.__dict__
        
        obj_dict["refCounter"] = int( dct.get("refCounter", 0) ) # в любом случае будем добавляться в TalentSet
        obj_dict["PersistentId"] = int( dct.get("PersistentId", 0) )
        obj_dict["IsNew"] = bool( dct.get("IsNew", False) )
        obj_dict["Points"] = int( dct.get("Points", 0) )
        obj_dict["GuildTalentId"] = int( dct.get("GuildTalentId", 0) )
        obj_dict["StaticSoulbound"] = int( dct.get("StaticSoulbound", 0) )

        try:
            actionBarIdx = int( dct.get("ActionBarIdx", -1) )
            obj_dict["ActionBarIdx"] = actionBarIdx
        except Exception:
            catch()
        
        try:
            ref_hero_id = int( dct.get("defaultForHero", 0) )
        except:
            # здесь попробуем поддержать старый вариант, {"Ref": {"<id>": <id>)}, чисто для скриптов конверсии
            ref_dict = dct.get("defaultForHero").get("Ref")
            dummy, ref_hero_id = getFirstPair( ref_dict )
            
        defaultForHero = Ref( md, hk, path, "defaultForHero" )
        defaultForHero.load_set( ref_hero_id )
        obj_dict["defaultForHero"] = defaultForHero

        try:
            ref_hero_id = int( dct.get("Soulbound", 0) )
        except:
            # здесь попробуем поддержать старый вариант, {"Ref": {"<id>": <id>)}, чисто для скриптов конверсии
            ref_dict = dct.get("Soulbound").get("Ref")
            dummy, ref_hero_id = getFirstPair( ref_dict )
            
        Soulbound = Ref( md, hk, path, "Soulbound" )
        Soulbound.load_set( ref_hero_id )
        obj_dict["Soulbound"] = Soulbound

        try:
            ref_gbi_id = int( dct.get("GuildBankInfo", 0) )
        except:
            # здесь попробуем поддержать старый вариант, {"Ref": {"<id>": <id>)}, чисто для скриптов конверсии
            ref_dict = dct.get("GuildBankInfo").get("Ref")
            dummy, ref_gbi_id = getFirstPair( ref_dict )
        GuildBankInfo = Ref( md, gbik, path, "GuildBankInfo" )
        GuildBankInfo.load_set( ref_gbi_id )
        obj_dict["GuildBankInfo"] = GuildBankInfo

        try:
            ref_hero_id = int( dct.get("Owner", 0) )
        except:
            # здесь попробуем поддержать старый вариант, {"Ref": {"<id>": <id>)}, чисто для скриптов конверсии
            ref_dict = dct.get("Owner").get("Ref")
            dummy, ref_hero_id = getFirstPair( ref_dict )

        Owner = Ref( md, hk, path, "Owner" )
        Owner.load_set( ref_hero_id )
        obj_dict["Owner"] = Owner

        smplDict = dct.get("ParentTalentSets", {"SimpleDict":{}})
        obj_dict["ParentTalentSets"] = self.fromSimpleDictForTalentSet(smplDict.get("SimpleDict",{}))

        #gldbankInfoDct = dct.get( "GuildBankInfo", None )
        #if gldbankInfoDct:
        #    gldbankInfoDct = gldbankInfoDct.get( "GuildBankInfo", None )
        #
        #obj_dict["GuildBankInfo"] = GuildBankInfo.GuildBankInfo( md, None, path + u"/GuildBankInfo" )
        #if gldbankInfoDct:
        #    obj_dict["GuildBankInfo"].GuildAuid = int( gldbankInfoDct.get("GuildAuid", 0) )
        #    obj_dict["GuildBankInfo"].GuildTalentId = int( gldbankInfoDct.get("GuildTalentId", 0) )
        #    obj_dict["GuildBankInfo"].HeroClassId = int( gldbankInfoDct.get("HeroClassId", 0) )
        #    obj_dict["GuildBankInfo"].OwnerId = int( gldbankInfoDct.get("OwnerId", 0) )

        ##print "-- opt_fromTalent CALLED: __dict__=%s" % obj.__dict__
        
        return obj
        
    #~ #---------------------------------------------------------------------
    #~ def opt_fromTalent( self, dct ):
        #~ path = str( dct.get("path", "") )
        #~ id = int( dct.get("id", 0) )
        #~ md = self.modeldata
        #~ hk = md.HeroesKeeper

        #~ TalentClass = self.SERIALIZABLE_CLASSES.get("Talent")
        #~ obj = TalentClass( md, id, path )
        #~ obj_dict = obj.__dict__
        
        #~ obj_dict["refCounter"] = int( dct.get("refCounter", 0) ) # в любом случае будем добавляться в TalentSet
        #~ obj_dict["PersistentId"] = int( dct.get("PersistentId", 0) )
        #~ obj_dict["IsNew"] = bool( dct.get("IsNew", False) )
        
        #~ # --- defaultForHero --------------------------------
        #~ ref_hero_id = dct.get("defaultForHero", 0)
        #~ if ref_hero_id.__class__ == int:
            #~ pass
        #~ elif ref_hero_id.__class__ == dict:
            #~ # попробуем поддержать старый вариант, {"Ref": {"<id>": <id>)}, чисто для скриптов конверсии
            #~ ref_dict = dct.get("defaultForHero").get("Ref")
            #~ dummy, ref_hero_id = getFirstPair( ref_dict )
        #~ else:
            #~ ref_hero_id = 0
                        
        #~ defaultForHero = Ref( md, hk, path, "defaultForHero" )
        #~ defaultForHero.load_set( ref_hero_id )
        #~ obj_dict["defaultForHero"] = defaultForHero

        #~ # --- Soulbound --------------------------------
        #~ ref_hero_id = dct.get("Soulbound", 0)
        #~ if ref_hero_id.__class__ == int:
            #~ pass
        #~ elif ref_hero_id.__class__ == dict:
            #~ # попробуем поддержать старый вариант, {"Ref": {"<id>": <id>)}, чисто для скриптов конверсии
            #~ ref_dict = dct.get("Soulbound").get("Ref")
            #~ dummy, ref_hero_id = getFirstPair( ref_dict )
        #~ else:
            #~ ref_hero_id = 0
            
        #~ Soulbound = Ref( md, hk, path, "Soulbound" )
        #~ Soulbound.load_set( ref_hero_id )
        #~ obj_dict["Soulbound"] = Soulbound
            
        #~ return obj
        
    #---------------------------------------------------------------------
    def opt_recurseFromClass( self, dct ):
        clsKey = dct.keys()[0]
        clsDict = dct[clsKey]
        ##warn( "opt_recurseFromClass: dct %s, clsKey %s" % ( str(dct)[:256], clsKey) )
        clsProc = self._decodeMethods.get(clsKey)
        if clsProc:
            return clsProc( clsDict )
        else:
            try:
                cls = self.SERIALIZABLE_CLASSES.get(clsKey)
                if not cls:
                    warn( "empty cls constructor for %s" % clsKey)
                    return
                #----------------------------------------------
                # тут пока оставим старый код
                obj = cls( self.modeldata )
                path = clsDict.get("path")
                obj_dict = obj.__dict__
                for key, val in clsDict.iteritems():
                    if isinstance( val, dict ):
                        obj_dict[key] = self.opt_recurseFromClass( val )
                    else:
                        field = obj_dict.get(key)
                        if field:
                            if (val.__class__ == int and field.__class__ == Ref):
                                # Ref -> int: RefType
                                field.load_set( int(val) ) # надо тупо поставить Ref на объект
                                if path: # и восстановить путь (Ref использует путь родителя)
                                    field.__dict__["path"] = path
                            else:
                                self.setTypedValue( obj, key, val )
                        else:
                            self.setTypedValue( obj, key, val )
                #----------------------------------------------

            except:
                err( "bad cls %r constructor",  cls)
                catch()                
                
            
            return obj
            
    #---------------------------------------------------------------------
    # только на этом уровне могут встречаться Keeper-ы
    def opt_fromModelData( self, vals ):
        obj = self.modeldata
        obj_dict = obj.__dict__
        restore_next_uid = not obj.next_uid_
        for key, val in vals.iteritems():
            if key in obj_dict:
                if obj_dict[key].__class__ == Keeper:
                    # keeper-ы надо не заменять в ModelData, а просто подменять dictionary (т.к. в процессе создания объекты успели наделать ссылок на modeldata.XxxxKeeper)
                    dictionary = self.opt_fromKeeper( val["Keeper"] )
                    
                    obj.__dict__[key].dictionary = dictionary
                    if restore_next_uid:
                        if dictionary:
                            max_key = max(dictionary)
                            obj.next_uid_ = max( max_key, obj.next_uid_ )
                            
                elif isinstance(val, dict):
                    val = self.opt_recurseFromClass( val )
                    self.setTypedValue( obj, key, val )
                    
                else:
                    self.setTypedValue( obj, key, val )
                    
            elif key[-1] == "_":
                self.setTypedValue( obj, key, val )
                
        ## if restore_next_uid:
            ## warn( "restored next_uid_: %s" % obj.next_uid_ )
            
        return obj


    #---------------------------------------------------------------------
    def fromDict( self, dct ):
        ########### подсчитаем количество "попаданий" в правильный тип при загрузке
        #~ self._non_matching_class = 0
        #~ self._matching_class = 0
        #~ self._conversion_class = 0
        #~ self._Refs = 0 
        #~ self._obj_Nones = 0
        #~ self._val_Nones = 0
        #~ self._objNoneCounts = IncDict()
        
        # на верхнем уровне должен лежать словарь с единственным ключом { "ModelData": ... }
        try:
            mdKey = dct.keys()[0]
            mdClass = self.SERIALIZABLE_CLASSES.get(mdKey)
            if not (mdClass is self.modeldata.__class__):
                print >>sys.stderr, "assert mdClass is self.modeldata.__class__ on dct: %r" % dct
                print >>sys.stderr, "mdClass is %r" % mdClass
                print >>sys.stderr, "self.modeldata.__class__ is %r" % self.modeldata.__class__
            assert mdClass is self.modeldata.__class__
            mdDict = dct[mdKey]
            model = self.opt_fromModelData( mdDict )
            
            ## hero = model.HeroesKeeper.get(1)
            ## warn( "hero[1] TS: %s" % hero.TalentSet.dictionary )
            
            #~ warn( "non-matching types: %s (conversions: %s, refs: %s, obj.None: %s, val.None: %s), matching types: %s" \
                #~ % (self._non_matching_class, self._conversion_class, self._Refs, self._obj_Nones, self._val_Nones, self._matching_class) )
            #~ warn( "objNoneCounts: %s " % self._objNoneCounts )
           
            #~ model_dict = model.generateJsonDict()
            #~ dumpfile = open("_last_fromDict.dump", "wt")
            #~ dumpfile.write(json_pretty(model_dict))
            #~ dumpfile.close()
            
            return model
        except Exception:
            catch()
            warn(errStack())
            raise
            pass # возвращаем None
        
        
    @staticmethod
    def updateOurTypes( typeTuple ):
        for t in typeTuple:
            if t not in JSONSerialization.OUR_TYPES:
                JSONSerialization.OUR_TYPES += ( t, )
                JSONSerialization.OUR_TYPES_DICT[ str(t) ] = 1
                
        #~ print( "OUR_TYPES: %s" % str(JSONSerialization.OUR_TYPES) )
        #~ print( "OUR_TYPES_DICT: %s" % JSONSerialization.OUR_TYPES_DICT )
