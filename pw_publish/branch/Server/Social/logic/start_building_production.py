#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
from subaction import *
from logic.requests.StartBuildingProductionRequest import StartBuildingProductionRequest

class Start_building_production( SubAction, StartBuildingProductionRequest ):
  """action, который будет обрабатывать данный класс"""
  action = "start_building_production"

  @model_callback # АВТОМАТИЧЕСКИ АПДЕЙТИМ ИЗМЕНЕНИЯ В MODEL DATA
  @parse
  @action_timing
  def onStart(self):
    """стартовый метод для обработки action"""
    self.log()
    # since StartBuildingProductionRequest.py is autogenerated, I had to put this check here:
    customValue = self.arguments.customValue
    if customValue < 0:
      warn("[StartBuildingProductionRequest] customValue < 0 ! ") # TODO remove this warn() later
      self.arguments.badParam( "customValue" ) # let self.checkParams() to create an error message

    if not self.checkParams():
      return
   
    construction = self.arguments.construction
    cycle = self.arguments.cycle

    if construction:    
      # Проверка, что здание у нас на в замке, а не на складе
      isFound = False
      for buildingId in self.acc.model.Buildings:
        if construction.getID() == buildingId:
          isFound = True
          break

      if not isFound:
        self.errorResponse( "Construction not found" )
        return

      for heroId in construction.HeroesInBuilding:
        hero = self.acc.model.getHeroByID( heroId )
        for buildingId in hero.InBuildings.keys():
          if not buildingId == construction.id:
            building = self.acc.model.getConstructionByID( buildingId )
            building.removeHeroFromBuilding( hero, self.acc, self.I )
              
      isCustom = construction.isCustomCycle(self.acc.SD, construction.Level, cycle)
      if isCustom:
        finalprice, fame = construction.getNonCustomProductionBonus(self.acc, self.I, construction.Level, cycle)
        if finalprice != None:
          if self.acc.SD.getFirstValue_old(finalprice) > customValue:
            self.errorResponse( "Custom production value under min limit" )
            return            
          
      isOk, self.duration = construction.getProductionDuration( self.acc, self.I, cycle, customValue )
      if isOk:
        if construction.ProductionState == ProductionState.Idle:
          self.price = construction.getProductionCost( self.acc, self.I, construction.Level, cycle, customValue )
          self.construction = construction
          self.cycle = cycle
          self.customValue = customValue
          self.isCustom = isCustom
          self.needGold = int( self.price.Gold )          
          reason = "PW!START_BUILDING_PRODUCTION:" + str( construction.PersistentId ) + ":" + str( cycle )
          self.buy( self.price, self.onBuy, self.onBuyFunc, reason )
          return None
        else:
          self.errorResponse( "Building state is not Idle" )
          return
      else:
        self.errorResponse( "Wrong Bath.duaration value: " + str(self.duration) )
        return
    else:
      self.errorResponse( "Construction is null" )
      return
    
    self.response["ok"] = 1 # success
    self.fin()


  @model_callback
  def onBuyFunc( self, response ):
    code = response["code"]
    if code == ibilling.ERROR_CODE_OK:
      self.doConfirmWriteOff( response )
      staticConstruction = self.acc.SD.getStaticConstruction( self.construction )
      self.construction.cycle = self.cycle
      if self.isCustom or staticConstruction['classType'] == "TransmutationBuilding":
        self.construction.ProductionCustomValue = self.customValue


      self.I.STATS.addResourcesChange( self.acc.auid, False, ResourceChangeItem.StartProduction,
                                         "%r (id=%r)" % ( staticConstruction['classType'], self.construction.id ),
                                         self.price, self.acc.model.Resources, self.arguments.aftercontext )
      
      restype = StatisticEventType.PRODUCTION_START
      if staticConstruction['classType'] == "ProductionBuilding" or staticConstruction['classType'] == "Tavern":
        restype = StatisticEventType.PRODUCTION_START
      elif staticConstruction['classType'] == "TransmutationBuilding":
        restype = StatisticEventType.TALENT_START
      self.acc.model.addStatisticEvent( restype, "Resource1", self.price.Resource1 )
      self.acc.model.addStatisticEvent( restype, "Resource2", self.price.Resource2 )
      self.acc.model.addStatisticEvent( restype, "Resource3", self.price.Resource3 )
      self.acc.model.addStatisticEvent( restype, "Silver", self.price.Silver )
      self.acc.model.addStatisticEvent( restype, "Perl", self.price.Perl )


      # Тут мы либо добавляем счетчик, либо обнуляем, а потом пересчитываем MDindex
      if staticConstruction['classType'] == "ProductionBuilding":
        if (int(round(time.time())) - self.construction.EndProductionTime) < self.acc.getConfigValue("SEC_TO_CHEAT_CYCLE"):
          self.construction.recalcMDindex( True, self.acc.getConfig() )
        else:
          self.construction.recalcMDindex( False, self.acc.getConfig() )

      self.construction.startProduction( self.duration, self.cycle, self.acc.model, self.acc.SD)
      
      if staticConstruction['classType'] == "Tavern":
        self.construction.BuildingQuest.StatSum = self.construction.getSumStatForTavern(self.acc.SD, self.acc, staticConstruction)

      self.response["ok"] = 1 # success
    else:
      self.onBuyError( response, self.needGold )
      return

    self.fin()


  @action_timing
  def onBuy( self, response ):
    self.onBuyFunc( response )

