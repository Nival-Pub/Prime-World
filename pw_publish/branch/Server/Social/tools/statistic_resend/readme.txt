2015.02.18

Набор скриптов, использовавшихся для вытаскивания из логов statistic_agent недошедших до сервера статистики пакетов.

Логи статистик-агента лежат в каталоге логов соцсервера на том хосте, где запущен статистик-агент, в файлах statistic.log и statistic.log-GGGGMMDD.gz (где GGGGMMDD - дата архивации файла (а не начала писания лога!)). Или может, других, если со времени написания этого файла что-то изменилось -- но тогда вы, скорее всего, сможете узнать имена логов из командой строки запуска агента и настроек ротации логов.

В логах статистик-агента отмечается получение данных от сервисов, отправка подготовленных пакетов на sstat и получение ответа sstat (либо ошибка запроса).
Все отправляемые пакеты логируются полностью. В одном пакете собраны события только одного типа. В записи об ответе присутствует id пакета, так что можно отследить, на какой пакет был какой ответ.
Небольшие тонкости:
1. В момент ротации логов какие-то пакеты пребывают в пути, так что запись об отправке будет в одном логе, а ответ -- в другом.
2. Не всякий таймаут отправки означает, что пакет не дошёл. Возможно дошёл, был принят в обработку, а вот отввет не успел сформироваться за короткий 20-секундный таймаут (его надо бы повысить!). Так что повторная отправка такого пакета может породить дубликат.
3. С другой сороны, даже принятие пакета в обработку sstat ещё не гарантирует успех, мало ли что там собьётся. Но лечится это только созданием системы потверждения обработки между statistic_agent и sstat.

Понятно, что редкие одиночные потери погоды не делают вообще, но вот в случае падения sstat перепослать пакеты за период простоя может быть необходимо.

Для этого надо взять все файлы логов (если они ещё не отротировались в ничто), желательно (но не обязательно) найти примерно начальный и конечный моменты.
Затем вписать их все в правильном порядке в sj.sh и выполнить команду:
./sj.sh | python collect.py > collect.log
(зжатые gzip'ом файлы ставить в команду zcat, несжатые - cat; промежуточные строки вида "echo Processing file FILENAME" полезны для проброски информации об обрабатываемом файле в лог скрипта collect.py)
Скрипт sj.sh обеспечит последовательное поступление всех логов единым потоком на вход скрипту collect.py, дабы избежать разрывов (см.п.1 в "Небольшие тонкости" выше) на границах фалов.

collect.py - получает на вход логи statistic_agent'а, для каждого отправленного пакета ищет ответ сервера и собирает те, для которых код http-ответа не равен 200. Результат работы записывает по 1 пакету (как их пытался отправить statistic_agent) на строку в файл  .
Попутно создаются файлы:
collected-no-response - те, на которые вообще не найдено никакого ответа, даже ошибки таймаута. Такое может быть в самом конце лога, а также если статистик-агент за данный период времени сам был остановлен до получения всех ответов.
collected-json - данные в том виде, как они пришли от прочих сервисов. В принципе, для наших целей не нужен (изначально рассматривался и варинт использования того, что сохраняется в него), можно выпилить его созжание из скрипта.
ВНИМАНИЕ: скрипт перезаписывает эти три файла именно с такими именами, не создавая резервных копий, если в момент запуска такие файлы уже есть.

Получив collected-unsent, пора подготовить условия для отправки. Скрипт statistic_resend.py получен достаточно спешной переделкой из statistic_agent.py, что позволило обеспечить преемственность метода отправки (кстати, не забудьте обновить скрипт, если успел измениться логика самого statistic_agent.py), но оставило в коде скрипта много бесполезного legacy, который просто поленился весь вычищать. И ещё требует, чтобы скрипт запускался в таком же окружении, что и сам statistic_agent.py, т.е. в корневом каталоге соцсервеера. Ну или его успешной имитации.
(Как быть, если прав на запись в каталог соцсервера нет? Я создал свой каталог, куда положил скрипт, его запускающую обёртку ws_StatisticResend.sh, создал там подкаталог logs, и сделал симлинки на ВСЕ файлы и подкаталоги коневого каталога соцсервера, кроме каталог logs.)
Помимо statistic_resend.py и ws_StatisticResend.sh в этот каталог нужно положить (или симлинкнуть) файл collected-unsent.

В качестве дополнительного этапа подготовки можно отфильтровать (grep -v) из collected-unsent пакеты тех типов, которые не нужно перепосылать.
Либо эти типы можно указать в скрпипте statistic_resend.py в переменной SKIP_TYPES. Сейчас там прописаны те типы, которые указал мне Антон Прокофьев, но, возможно, в другой раз список придётся изменить.

Также statistic_resend.py умеет читать в текущем каталоге файл ids.ok, где перечислены, по 1 в строке, id успешно отправленных пакетов -- такие пакеты он будет пропускать при отправке.
Такой же файл он создаёт в каталоге logs (затирая старый на том месте!), выводя туда id новых успешно доставленные пакеты. Это позволяет запускать его несколько раз подряд на одном и том же файле collected-unsent (после каждого запуска содержимое logs/ids.ok надо добавить к ./ids.ok, т.е.: cat logs/ids.ok >> ./ids.ok).
Чтобы не перепутываться с тем, что в данный момент, возможно, шлёт нормальный statistic_agent, я добавлял фиксированное большое число к id пакетов из collected-unsent, число это задано в переменной ID_SHIFT.

Чтобы не создавать перегрузку на sstat, между получением ответа на посылку пакета и отправкой нового скрипт делает мини-паузу, размер которой равен коичеству событий в пакете, умноженному на BASE_READ_GAP, при этом одновременно запускаются несколько (до 4) цепочек отправки пакетов. В случае слишком большого времени между посылкой и ответом, данная пауза увеличивается мнгократно, что позволяет автоматически снижать нагрузку на sstat, если он не успевает принять наши пакеты. Как показала практика, при текущей загруженности sstat установка BASE_READ_GAP=0.05 позволяет ему работать круглосуточно, хотя на ночное время величину можно и уменьшать, где-то то 0.03 или 0.025.

Строка запуска, которой пользовался я сам:

$ bash ws_StatisticResend.sh &>> logs/wsStatisticResend.log

При этом в логе можно отслеживать случаи сильного увеличения времени ответа sstat, чтобы при необходимости остановить скрипт.
(После остановки не забыть сделать: cat logs/ids.ok >> ./ids.ok )

Скрипт сам завершает работу, когда пройдёт по всем записям в collected-unsent, однако, он не умеет перепосылать то, что не получилось отослать, так что может быть полезно запустить его ещё раз (не забыв сделать: cat logs/ids.ok >> ./ids.ok), пока на очередном запуске все пакеты будут либо уже отосланные, либо отфильтрованы по SKIP_TYPES.

Дополнительно в комплекте есть:
splitpkg.py - конвертирует резульат работы collect.py, разделяя пакеты и выводя по одному объекту статистики на строку для работы требует каталог thrift_pw (можно симлинком) из развёртывания соцсервера. Использовался для оценки количества событий (не пакетов - в пакетах бывает и много, и мало событий).
find_already_sent.sh - позволяет воссоздать ids.ok прошлого запуска по логу logs/wsStatisticResend.log, если по ошибке ids.ok был перезаписан, а не дополнен файлом logs/ids.ok

