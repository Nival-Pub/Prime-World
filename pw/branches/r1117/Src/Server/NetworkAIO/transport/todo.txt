2010.12.13
+ т.к. каналы устанавливаютс€ последовательно, то не генерим pipeid при установке каналов а используем один и тот же идентификатор
==========================================
2010.12.09
------------------
? нужен ли void OpenConnectionOp::OnConnection(bool /*success*/, ChannelContextStrongPtr const & /*spcc*/)
 
==========================================
2010.12.08
------------------
- стоит хранить в мэпе acceptor'ов AcceptorHandle вместо AcceptorSP
+ баг детектед в случае обработки нескольких пакетов на сетевом уровне:
с poutmb надо работать через cont()
(надо заюзать обработчик из netlayer, там пофикшено)
==========================================
2010.11.30
------------------
+ перевод внутренностей на ACE strong/weak pointer'ы
+ фикс бага с messageBlockFactory (вызывалс€ free_msg у уже убитой фабрики)
+ пофикшен баг, в список установленных соединений в ConnectionManager::OnConnectionEstablished 
  могло добавитс€ неустаноленное соединение

? стоит ли возвращать 0 из MessageBlockFactory::alloc_msg(не везде сто€т проверки)

- mb в TL::SendData может быть Ќ≈ освобожден в случае если не вызвать SendData::complete()
  см. в   int BaseProtocol::on_user_operation(Terabit::AsynchChannel *channel, Operation* op)
       if (spcc.null())

==========================================
first realization
------------------
- корректное закрытие соединени€
  - на случай встречного закрыти€ соединени€ - похоже надо завести стейт CANCEL(между OPEN & CLOSED)
- обработка нового вход€щего канала
- задавать packaddr в канале (сейчас true - т.е. клиент)
- flag - connected/accepted
- логирование
- разобратьс€ с assingChannelId()/freeChannelId() (учитывать дефолтные pipe'ы)

+ нужна очередь операций в канале
+ все операции должны возвращать naio::StatusT (см. обработка rc в TL::ProtocolHandler::HandleOutput)
+ обработка вход€щих транспортных сообщений
