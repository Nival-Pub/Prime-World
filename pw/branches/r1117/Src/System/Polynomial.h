#pragma once

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const float FP_ROOT_EPSILON = sqrtf(1.192092896e-07F);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Quartic equations: c1*x+c0 = 0 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool SolvePolynomialEquation(
		float						_fC0, 
		float						_fC1, 
		vector<float> &	_Roots
	)
{
	_Roots.clear();

	if (fabsf(_fC1) > FP_ROOT_EPSILON)
		_Roots.push_back(-_fC0 / _fC1);

	return !_Roots.empty();
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Quartic equations: c2*x^2+c1*x+c0 = 0 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
inline bool SolvePolynomialEquation(
		float						_fC0, 
		float						_fC1, 
		float						_fC2, 
		vector<float> &	_Roots
	)
{
	if (fabsf(_fC2) <= FP_ROOT_EPSILON)
	{
		// Polynomial is linear
		return SolvePolynomialEquation(_fC0, _fC1, _Roots);
	}

	// Clear previons roots
	_Roots.clear();

	float fDSC = _fC1 * _fC1 - 4.0f * _fC0 * _fC2;
	if (fDSC < 0.0)
		return false;

	float fInvC2 = 0.5f / _fC2;

	if (fabsf(fDSC) <= FP_ROOT_EPSILON)
	{
		_Roots.push_back(-fInvC2 * _fC1);
	}
	else
	{
		fDSC = sqrtf(fDSC);

		_Roots.push_back(fInvC2 * (-_fC1 - fDSC));
		_Roots.push_back(fInvC2 * (-_fC1 + fDSC));
	}

	return true;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
