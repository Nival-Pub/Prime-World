/*
 *  CVS Revision:$Id: expreport.cpp,v 1.15 2007/06/01 17:02:56 earnol Exp $
 *
 */

/**
  @file
  @brief    Exception report module
  @date     Created on 18/04/2007
  @project  NBSU
  @author   Earnol
*/
// *******************************************************************
// compiler specific

// *******************************************************************
// includes
// engine

//#pragma warning (push)

#include "StdAfx.h"
#pragma warning (disable : 4996 4201 4505)

// standard
#include <shlwapi.h>
#include <Imagehlp.h>
#include <Setupapi.h>
#include <cfgmgr32.h>
#include <Winioctl.h>

// ATL stuff
#include "expreport.h"
#include "LogFileName.h"
#include <msxml2.h>

#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "Imagehlp.lib")

#ifndef DIM
  #define DIM(a) (sizeof((a)) / sizeof(*(a)))
#endif  //DIM


namespace NBSU
{
// *******************************************************************
// defines & constants

#define FILE_REMOVABLE_MEDIA            0x00000001
#define FILE_READ_ONLY_DEVICE           0x00000002
#define FILE_FLOPPY_DISKETTE            0x00000004
#define FILE_WRITE_ONCE_MEDIA           0x00000008
#define FILE_REMOTE_DEVICE              0x00000010
#define FILE_DEVICE_IS_MOUNTED          0x00000020
#define FILE_VIRTUAL_VOLUME             0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME  0x00000080
#define FILE_DEVICE_SECURE_OPEN         0x00000100

#define makeStr(a)  L#a

struct DXReferenceStruct
{
  TCHAR const * cpVerStr;
  TCHAR const * cpDxVersion;
};

// *******************************************************************
// static data
SystemReport::ProcessorArchitecture const SystemReport::_architecturesList[] = 
{
  {PROCESSOR_ARCHITECTURE_INTEL        ,makeStr(PROCESSOR_ARCHITECTURE_INTEL        )},
  {PROCESSOR_ARCHITECTURE_MIPS         ,makeStr(PROCESSOR_ARCHITECTURE_MIPS         )},
  {PROCESSOR_ARCHITECTURE_ALPHA        ,makeStr(PROCESSOR_ARCHITECTURE_ALPHA        )},
  {PROCESSOR_ARCHITECTURE_PPC          ,makeStr(PROCESSOR_ARCHITECTURE_PPC          )},
  {PROCESSOR_ARCHITECTURE_SHX          ,makeStr(PROCESSOR_ARCHITECTURE_SHX          )},
  {PROCESSOR_ARCHITECTURE_ARM          ,makeStr(PROCESSOR_ARCHITECTURE_ARM          )},
  {PROCESSOR_ARCHITECTURE_IA64         ,makeStr(PROCESSOR_ARCHITECTURE_IA64         )},
  {PROCESSOR_ARCHITECTURE_ALPHA64      ,makeStr(PROCESSOR_ARCHITECTURE_ALPHA64      )},
  {PROCESSOR_ARCHITECTURE_MSIL         ,makeStr(PROCESSOR_ARCHITECTURE_MSIL         )},
  {PROCESSOR_ARCHITECTURE_AMD64        ,makeStr(PROCESSOR_ARCHITECTURE_AMD64        )},
  {PROCESSOR_ARCHITECTURE_IA32_ON_WIN64,makeStr(PROCESSOR_ARCHITECTURE_IA32_ON_WIN64)},
  {PROCESSOR_ARCHITECTURE_UNKNOWN      ,makeStr(PROCESSOR_ARCHITECTURE_UNKNOWN      )},
};

SystemReport::ProcessorFeature const SystemReport::_procFeaturesList[] = 
{
  {PF_FLOATING_POINT_PRECISION_ERRATA ,makeStr(PF_FLOATING_POINT_PRECISION_ERRATA)},     
  {PF_FLOATING_POINT_EMULATED         ,makeStr(PF_FLOATING_POINT_EMULATED        )},     
  {PF_COMPARE_EXCHANGE_DOUBLE         ,makeStr(PF_COMPARE_EXCHANGE_DOUBLE        )},     
  {PF_MMX_INSTRUCTIONS_AVAILABLE      ,makeStr(PF_MMX_INSTRUCTIONS_AVAILABLE     )},     
  {PF_PPC_MOVEMEM_64BIT_OK            ,makeStr(PF_PPC_MOVEMEM_64BIT_OK           )},     
  {PF_ALPHA_BYTE_INSTRUCTIONS         ,makeStr(PF_ALPHA_BYTE_INSTRUCTIONS        )},     
  {PF_XMMI_INSTRUCTIONS_AVAILABLE     ,makeStr(PF_XMMI_INSTRUCTIONS_AVAILABLE    )},     
  {PF_3DNOW_INSTRUCTIONS_AVAILABLE    ,makeStr(PF_3DNOW_INSTRUCTIONS_AVAILABLE   )},     
  {PF_RDTSC_INSTRUCTION_AVAILABLE     ,makeStr(PF_RDTSC_INSTRUCTION_AVAILABLE    )},     
  {PF_PAE_ENABLED                     ,makeStr(PF_PAE_ENABLED                    )},     
  {PF_XMMI64_INSTRUCTIONS_AVAILABLE   ,makeStr(PF_XMMI64_INSTRUCTIONS_AVAILABLE  )},    
  {PF_SSE_DAZ_MODE_AVAILABLE          ,makeStr(PF_SSE_DAZ_MODE_AVAILABLE         )},    
  {PF_NX_ENABLED                      ,makeStr(PF_NX_ENABLED                     )},    
};

SystemReport::CPUIdFeatureTable const SystemReport::_cpuIDFeatureList[] = 
{
  {0x01, 0x00000000},
  {0x02, 0x80000004},
  {0x03, 0x00000000},
  {0x05, 0x80000008},
  {0x06, 0x80000008},
  {0x0A, 0x80000008},
  {0x0D, 0x80000008},
};

DXReferenceStruct const _dxRefList[] =
{
  {_T("4.02.0095"     ), _T("1.0")},
  {_T("4.03.00.1096"  ), _T("2.0")},
  {_T("4.04.0068"     ), _T("3.0")},
  {_T("4.04.0069"     ), _T("3.0")},
  {_T("4.05.00.0155"  ), _T("4.0")},
  {_T("4.05.01.1721"  ), _T("5.0")},
  {_T("4.05.01.1998"  ), _T("5.0")}, 
  {_T("4.06.02.0436"  ), _T("6.0" )},
  {_T("4.07.00.0700"  ), _T("7.0" )},
  {_T("4.07.00.0716"  ), _T("7.0a")},
  {_T("4.08.00.0400"  ), _T("8.0" )},
  {_T("4.08.01.0881"  ), _T("8.1" )},
  {_T("4.08.01.0810"  ), _T("8.1" )},
  {_T("4.09.0000.0900"), _T("9.0" )},
  {_T("4.09.00.0900"  ), _T("9.0" )},
  {_T("4.09.0000.0901"), _T("9.0a")},
  {_T("4.09.00.0901"  ), _T("9.0a")},
  {_T("4.09.0000.0902"), _T("9.0b")},
  {_T("4.09.00.0902"  ), _T("9.0b")},
  {_T("4.09.00.0904"  ), _T("9.0c")},
  {_T("4.09.0000.0904"), _T("9.0c")},
};

// *******************************************************************
// functions

FILETIME GetLastWriteFileTime(wstring const &sFile)
{
  FILETIME          ftLocal = {0};
  HANDLE            hFind;
  WIN32_FIND_DATAW   ff32;
  hFind = FindFirstFileW(sFile.c_str(), &ff32);
  if (INVALID_HANDLE_VALUE != hFind)
  {
    FileTimeToLocalFileTime(&(ff32.ftLastWriteTime), &ftLocal);
    FindClose(hFind);        
  }
  return ftLocal;
}

/**
@brief    Returns directX Version installed on PC

@return   DX version string
@author   Earnol
*/
CString GetDirectXVersion()
{
  HKEY pKey;
  CString sRetStr(_T("Not installed"));
  CString strBuffer(_T(""));
  DWORD   nI;

  if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\DirectX"), 0, KEY_READ, &pKey))
  {
    DWORD nSize = _MAX_PATH;
    RegQueryValueEx(pKey, _T("Version"), NULL, NULL, (LPBYTE)strBuffer.GetBuffer(_MAX_PATH + 1), &nSize);
    strBuffer.ReleaseBuffer();
    RegCloseKey(pKey);
    for(nI =0 ; nI < DIM(_dxRefList); nI++)
    {
      if(strBuffer == _dxRefList[nI].cpVerStr)
      {
        sRetStr = _dxRefList[nI].cpDxVersion;
        return sRetStr;
      }
    }
    sRetStr = _T("Unknown DirectX version. Version string is: ");
    sRetStr += strBuffer;
  }
  return sRetStr;
} // end of GetDirectXVersion

// *******************************************************************
// methods 

/**
  @brief    Constructor

  @param    ExceptionInfo
  @see      @documentme
  @author   Earnol
*/
SystemReport::SystemReport()
{
} // end of NBSU::NBSU


/**
  @brief    Just serach in internal array

  @return   Null if nothing found
  @param    nCode processor code to search for
  @author   Earnol
*/
SystemReport::ProcessorArchitecture const *SystemReport::GetProcessorArchitectureInfo(DWORD nCode)
{
  DWORD nI;
  for(nI = 0; nI < DIM(_architecturesList); nI++)
  {
    if(nCode == _architecturesList[nI].nCode)
    {
      return &_architecturesList[nI];
    }
  }
  return NULL;
} // end of NBSU::GetProcessorArchitectureInfo



bool SystemReport::FormatDOMDocument(CComPtr<IXMLDOMDocument> &pDoc)
{
  // Create the writer
  CComPtr <IMXWriter> pMXWriter;
  if (FAILED (pMXWriter.CoCreateInstance(__uuidof (MXXMLWriter), NULL, CLSCTX_ALL))) {
    return false;
  }
  CComPtr <ISAXContentHandler> pISAXContentHandler;
  if (FAILED (pMXWriter.QueryInterface(&pISAXContentHandler))) {
    return false;
  }
  CComPtr <ISAXErrorHandler> pISAXErrorHandler;
  if (FAILED (pMXWriter.QueryInterface (&pISAXErrorHandler))) {
    return false;
  }
  CComPtr <ISAXDTDHandler> pISAXDTDHandler;
  if (FAILED (pMXWriter.QueryInterface (&pISAXDTDHandler))) {
    return false;
  }

  if (FAILED (pMXWriter->put_omitXMLDeclaration (VARIANT_FALSE)) ||
    FAILED (pMXWriter->put_standalone (VARIANT_TRUE)) ||
    FAILED (pMXWriter->put_indent (VARIANT_TRUE)) ||
    FAILED (pMXWriter->put_encoding (L"UTF-16")))
  {
    return false;
  }

  // Create the SAX reader
  CComPtr <ISAXXMLReader> pSAXReader;
  if (FAILED(pSAXReader.CoCreateInstance(__uuidof (SAXXMLReader), NULL, CLSCTX_ALL))) {
    return false;
  }

  if (FAILED(pSAXReader->putContentHandler (pISAXContentHandler)) ||
    FAILED(pSAXReader->putDTDHandler (pISAXDTDHandler)) ||
    FAILED(pSAXReader->putErrorHandler (pISAXErrorHandler)) ||
    FAILED(pSAXReader->putProperty (L"http://xml.org/sax/properties/lexical-handler", CComVariant (pMXWriter))) ||
    FAILED(pSAXReader->putProperty (L"http://xml.org/sax/properties/declaration-handler", CComVariant (pMXWriter))))
  {
    return false;
  }

  // Perform the write
  bool success1 = SUCCEEDED(pMXWriter->put_output(CComVariant(pDoc)));
  bool success2 = SUCCEEDED(pSAXReader->parse(CComVariant(pDoc)));

  return success1 && success2;
}

//-----------------------------------------------------------------------------
// NBSU::getCrashLog
//
// Creates the XML log file returning the name
//
bool SystemReport::dumpSystemInfo(bool bNeedDeviceInformation)
{
   wstring sFile;

   // Create an empty XML document
   CComPtr<IXMLDOMDocument> pDoc;
   pDoc.CoCreateInstance(__uuidof(DOMDocument), NULL, CLSCTX_INPROC_SERVER);

   if(!pDoc)
   {
     return false;
   }

   //add header
   CComPtr<IXMLDOMProcessingInstruction> processing;
   pDoc->createProcessingInstruction(L"xml", L"version=\"1.0\" encoding=\"utf-16\"", &processing);
   pDoc->appendChild(processing, NULL);

   // Create root node
   TElem root;
   root = root.createChildNode(pDoc, L"SystemInformation");
   
   // Add processor node
   TElem processorNode = root.createChildNode(pDoc, L"Processor");
   FillProcessorNode(processorNode);
   
   // Add OS node
   TElem osNode = root.createChildNode(pDoc, L"OperatingSystem");
   FillOSNode(osNode);
   
   // Add modules node
   TElem modulesNode = root.createChildNode(pDoc, L"Modules");
   FillModulesNode(modulesNode, pDoc);

   // Add memory information node
   TElem memoryNode = root.createChildNode(pDoc, L"MemoryInformation");
   FillMemoryNode(memoryNode, pDoc);

   // Add DirectX information node
   TElem directXNode = root.createChildNode(pDoc, L"DXInformation");
   FillDirectXNode(directXNode, pDoc);

   // Add device information node
   if(bNeedDeviceInformation)
   {
     TElem deviceNode = root.createChildNode(pDoc, L"DeviceInformation");
     FillDevicesNode(deviceNode, pDoc);
   }

   FormatDOMDocument(pDoc);

   // Create the dump file name
   string xmlName = NDebug::GenerateDebugFileName("system", "xml");
   systemLog( NLogg::LEVEL_DEBUG ) << "System configuration dumped to file: " << xmlName << endl;
   CComVariant saveName(xmlName.c_str());
   pDoc->save(saveName);
   return true;
}


/**
  @brief    Create Processor Node

  @return   Processor information node
  @param    pDoc
  @author   Earnol
*/
void SystemReport::FillProcessorNode(TElem &pNode)
{
   WCHAR const *archName                    = L"Architecture"      ;
   WCHAR const *levelName                   = L"Level"             ;
   WCHAR const *typeName                    = L"Type"              ;
   WCHAR const *numberName                  = L"NumberOfProcessors";
   WCHAR const *processorRevName            = L"ProcessorRevision" ;
   WCHAR const *processorBrandString        = L"ProcessorBrandString" ;
   SYSTEM_INFO si;


   // Get processor info
   GetSystemInfo(&si);

   ProcessorArchitecture const *pInfo = GetProcessorArchitectureInfo(si.wProcessorArchitecture);
   if(pInfo != NULL)
   {
     pNode.addAttr(archName, pInfo->cpCodeText);
   }
   else
   {
     pNode.addAttr(archName, L"Unknown");
   }

   if(PROCESSOR_ARCHITECTURE_INTEL == si.wProcessorArchitecture)
   {
     switch(si.dwProcessorType)
     {
       case PROCESSOR_INTEL_386:
       {
         pNode.addAttr(typeName, L"Intel 80386");
         break;
       }
       case PROCESSOR_INTEL_486:
       {
         pNode.addAttr(typeName, L"Intel 80486");
         break;
       }
       case PROCESSOR_INTEL_PENTIUM:
       {
         if(IsProcessorFeaturePresent(PF_3DNOW_INSTRUCTIONS_AVAILABLE))
         {
           pNode.addAttr(typeName, L"AMD");
         }
         else
         {
           pNode.addAttr(typeName, L"Intel Pentium");
         }
         break;
       }
       case PROCESSOR_INTEL_IA64: 
       {
         pNode.addAttr(typeName, L"Intel Itanium 64");
         break;
       }
       case PROCESSOR_AMD_X8664: 
       {
         pNode.addAttr(typeName, L"AMD");
         break;
       }
       default:
       {
         pNode.addAttr(typeName, L"Unknown");
       }
     }
   }
   pNode.addAttr(levelName, si.wProcessorLevel);
   // Set num of processors
   pNode.addAttr(numberName, si.dwNumberOfProcessors);
   pNode.addAttr(processorRevName, si.wProcessorRevision);
   DWORD nI;
   for(nI = 0; nI < DIM(_procFeaturesList); nI++)
   {
     pNode.addAttr(_procFeaturesList[nI].cpFeatureText, IsProcessorFeaturePresent(_procFeaturesList[nI].nFeature) == TRUE);
   }
   DWORD nMaxBasicFunction = 0;
   DWORD nMaxExtFunction   = 0; 
   __asm
   {
     xor eax, eax
     cpuid
     mov nMaxBasicFunction, eax
   }
   if(nMaxBasicFunction >= 1)
   {
     DWORD neax;
     DWORD necx;
     DWORD nedx;
     __asm
     {
       xor eax, eax
       inc eax
       cpuid
       mov neax, eax
       mov necx, ecx
       mov nedx, edx
     }
     pNode.addAttr(L"Stepping_ID"         , (neax & 0x000000F) >> 0);   //bits 0 - 3
     pNode.addAttr(L"Model"               , (neax & 0x00000F0) >> 4);   //bits 4 - 7
     pNode.addAttr(L"Family_ID"           , (neax & 0x0000F00) >> 8);   //bits 8 - 11
     pNode.addAttr(L"Processor_Type"      , (neax & 0x0003000) >> 12);  //bits 12 - 13
     pNode.addAttr(L"Extended_Model_ID"   , (neax & 0x00F0000) >> 16);  //bits 16 - 19
     pNode.addAttr(L"Extended_Family_ID"  , (neax & 0xFF00000) >> 20);  //bits 20 - 27
     CString strName(_T(""));
     strName.Format(_T("%X"), necx);
     pNode.addAttr(L"Basic_feature_flags_1" , strName);
     strName.Format(_T("%X"), nedx);
     pNode.addAttr(L"Basic_feature_flags_2" , strName);  //bits 20 - 27
     //ask extended features
     __asm
     {
       mov eax, 80000000h
       cpuid
       mov nMaxExtFunction, eax
     }
     if(nMaxExtFunction >= 0x80000000 && nMaxExtFunction <= 0x80000100) //ext function supported
     {
       if(nMaxExtFunction >= 0x80000004) //model id is here
       {
         char modelID[12 * 4 + 1];
         modelID[12 * 4] = '\0';
         DWORD *pMdl = (DWORD *)&modelID[0];
         __asm
         {
           push esi
           mov esi, pMdl
           mov eax, 80000002h
           cpuid
           mov [esi + 00h], eax
           mov [esi + 04h], ebx
           mov [esi + 08h], ecx
           mov [esi + 0Ch], edx
           mov eax, 80000003h
           cpuid
           mov [esi + 10h], eax
           mov [esi + 14h], ebx
           mov [esi + 18h], ecx
           mov [esi + 1Ch], edx
           mov eax, 80000004h
           cpuid
           mov [esi + 20h], eax
           mov [esi + 24h], ebx
           mov [esi + 28h], ecx
           mov [esi + 2Ch], edx
           pop esi
         }
         strName = modelID;
         pNode.addAttr(processorBrandString, strName);
       }
     }

   }

   return ;
} // end of SystemReport::FillProcessorNode

/**
  @brief    Fill Windows Node

  @return   Windows information node
  @param    pNode node to be filled
  @author   Earnol
*/
void SystemReport::FillOSNode(TElem &pNode)
{
   WCHAR const *majorName                   = L"MajorVersion";
   WCHAR const *minorName                   = L"MinorVersion";
   WCHAR const *buildName                   = L"BuildNumber";
   WCHAR const *csdName                     = L"CSDVersion";
   OSVERSIONINFO oi;

   // Get OS info
   oi.dwOSVersionInfoSize = sizeof(oi);
   GetVersionEx(&oi);

   // Set major version
   pNode.addAttr(majorName, oi.dwMajorVersion);
   // Set minor version
   pNode.addAttr(minorName, oi.dwMinorVersion);
   // Set build version
   pNode.addAttr(buildName, oi.dwBuildNumber);
   // Set SP version
   pNode.addAttr(csdName, oi.szCSDVersion);
   return;
} // end of SystemReport::FillOSNode

/**
@brief    Fill memory information node

@param    pNode node to be filled
@param    pDoc document for subnode creation
@author   Earnol
*/
void SystemReport::FillDirectXNode(TElem &pNode, CComPtr<IXMLDOMDocument> &pDoc)
{
  WCHAR const *versionName                   = L"InstalledVersion"  ;
  WCHAR const *debugName                     = L"DebugRuntime"      ;  
  WCHAR const *moduleName                    = L"Module"            ;  
  CString     strD3DRoot                     = _T("SOFTWARE\\Microsoft\\Direct3d"); 
  USES_CONVERSION;
  
  UNREFERENCED_PARAMETER(pDoc);
  pNode.addAttr(versionName, GetDirectXVersion());
  DWORD nType;
  DWORD nDW = 0;
  DWORD nDataSize = sizeof(nDW);
  if(ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, strD3DRoot, _T("LoadDebugRuntime"), &nType, &nDW, &nDataSize))
  {
    pNode.addAttr(debugName, false);
  }
  else
  {
    pNode.addAttr(debugName, nDW != 0);
  }
  CString strBuffer(_T('\0'));
  GetSystemDirectory(strBuffer.GetBuffer(MAX_PATH + 1), MAX_PATH);
  strBuffer.ReleaseBuffer();
  strBuffer += _T("\\d3d*.dll");
  CFindFile findFile;
  if(findFile.FindFile(strBuffer))
  {
    do 
    {
      if(!findFile.IsDirectory())
      {
        MINIDUMP_MODULE_CALLBACK  moduleDesc;
        LOADED_IMAGE              image;
        CString                   filePath = findFile.GetFilePath();
        LPSTR                     stDBPath = (LPSTR)malloc(sizeof(TCHAR) * MAX_PATH * 10);
        LPCTSTR                   cpFileName = filePath;
        if(MapAndLoad(filePath , NULL, &image, TRUE, TRUE))
        {
          moduleDesc.BaseOfImage = image.FileHeader->OptionalHeader.ImageBase;
          moduleDesc.CheckSum    = image.FileHeader->OptionalHeader.CheckSum;
          moduleDesc.CvRecord    = NULL;
          moduleDesc.FullPath    = A2W(cpFileName);
          moduleDesc.MiscRecord  = NULL;
          moduleDesc.SizeOfCvRecord   = 0;
          moduleDesc.SizeOfImage      = image.SizeOfImage;
          moduleDesc.SizeOfMiscRecord = 0;
          moduleDesc.TimeDateStamp    =  image.FileHeader->FileHeader.TimeDateStamp;
          moduleDesc.VersionInfo.dwFileVersionLS = image.FileHeader->OptionalHeader.MinorImageVersion;
          moduleDesc.VersionInfo.dwFileVersionMS = image.FileHeader->OptionalHeader.MajorImageVersion;
          moduleDesc.VersionInfo.dwProductVersionLS = image.FileHeader->OptionalHeader.MinorSubsystemVersion;
          moduleDesc.VersionInfo.dwProductVersionMS = image.FileHeader->OptionalHeader.MajorSubsystemVersion;
          TElem pModule = pNode.createChildNode(pDoc, moduleName);
          FillModuleNode(pModule, pDoc, &moduleDesc);
          UnMapAndLoad(&image);
        }
        free(stDBPath);
      }
    } while(findFile.FindNextFile());
  }


  return;
} // end of SystemReport::FillDirectXNode

void GetDeviceInterfaceInfo(HDEVINFO hDevInfo, SP_DEVINFO_DATA spDevInfoData, CString &szPath)
{
  SP_DEVICE_INTERFACE_DATA spDevInterfaceData = {0};
  //
  spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
  if(FALSE == SetupDiCreateDeviceInterface(hDevInfo, &spDevInfoData, &spDevInfoData.ClassGuid, 0L, 0L, &spDevInterfaceData))
  {
    NI_ASSERT(FALSE, "");
  }
  else
  {
    SP_DEVICE_INTERFACE_DETAIL_DATA *pspDevInterfaceDetail = 0L;
    DWORD                           dwRequire              = 0L;
    //
    if(FALSE == SetupDiGetDeviceInterfaceDetail(hDevInfo, &spDevInterfaceData, 0L, 0, &dwRequire, 0L))
    {
      DWORD dwError = GetLastError();
      //
      if(dwError != ERROR_INSUFFICIENT_BUFFER)
      {
        NI_ASSERT(false, "");
        return;
      }
    }
    //
    pspDevInterfaceDetail = (SP_DEVICE_INTERFACE_DETAIL_DATA *)LocalAlloc(LPTR, sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) * dwRequire);
    pspDevInterfaceDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
    if(FALSE == SetupDiGetDeviceInterfaceDetail(hDevInfo, &spDevInterfaceData, pspDevInterfaceDetail, dwRequire, &dwRequire, 0L))
    {
      DWORD dwError = GetLastError();
      //
      if(dwError != ERROR_INSUFFICIENT_BUFFER)
      {
        NI_ASSERT(FALSE, "");
      }
    }
    else
    {
      szPath = pspDevInterfaceDetail->DevicePath;
    }
    //
    if(pspDevInterfaceDetail)
      LocalFree(pspDevInterfaceDetail);
  }
}

void GetDeviceInstanceID(HDEVINFO hDevInfo, SP_DEVINFO_DATA* pspDevInfoData, TCHAR *szInstanceID)
{
  if(FALSE == SetupDiGetDeviceInstanceId(hDevInfo, pspDevInfoData, szInstanceID, LINE_LEN, 0))
  {
    NI_ASSERT(false, "");
  }
}

template <typename T> void AddStringFlag(CString &str, T const *strFlag)
{
  if(str == _T(""))
  {
    str = strFlag;
  }
  else
  {
    str += _T(" | ");
    str += strFlag;
  }
}

void GetDriverName(TElem pNode, TCHAR const *szServiceName)
{
  HKEY  hKey             = 0L;
  CString szSubKey(_T("SYSTEM\\CurrentControlSet\\Services\\\0"));
  CString szPath;
  DWORD cbData;
  DWORD dwType;
  DWORD dwStart;
  //
  szSubKey += szServiceName;
  if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
  {
    return;
  }
  //
  cbData = 0;
  dwType = REG_EXPAND_SZ;
  if(RegQueryValueEx(hKey, _T("ImagePath"), 0L, &dwType, NULL, &cbData) == ERROR_SUCCESS)
  {
    LPTSTR szPathBuff =  szPath.GetBuffer(cbData);
    if(RegQueryValueEx(hKey, _T("ImagePath"), 0L, &dwType, (LPBYTE)szPathBuff, &cbData) == ERROR_SUCCESS)
    {    
      szPath.ReleaseBuffer();
      TCHAR szRoot[MAX_PATH + 1] = {0};
      //
      GetWindowsDirectory(szRoot, MAX_PATH);
      szPath = _T("\\") + szPath;
      szPath = szRoot + szPath;
      pNode.addAttr(L"ImagePath", szPath);
    }
    else
    {
      szPath.ReleaseBuffer();
    }
  }
  //
  szPath.Empty();
  cbData = 0;
  dwType = REG_SZ;
  if(RegQueryValueEx(hKey, _T("Group"), 0L, &dwType, NULL, &cbData) == ERROR_SUCCESS)
  {
    LPTSTR szPathBuff =  szPath.GetBuffer(cbData);
    if (RegQueryValueEx(hKey, _T("Group"), 0L, &dwType, (LPBYTE)szPathBuff, &cbData) == ERROR_SUCCESS)
    {
      szPath.ReleaseBuffer();
      pNode.addAttr(L"Group", szPath);
    }
    else
    {
      szPath.ReleaseBuffer();
    }
  }
  //
  dwStart = 0;
  cbData  = sizeof(DWORD);
  dwType  = REG_DWORD;
  if(RegQueryValueEx(hKey, _T("Start"), 0L, &dwType, (LPBYTE)&dwStart, &cbData) == ERROR_SUCCESS)
  {
    switch(dwStart)
    {
      case SERVICE_BOOT_START:
      {
        szPath = _T("BOOT START");
        break;
      }
      case SERVICE_SYSTEM_START:
      {
        szPath = _T("SYSTEM START");
        break;
      }
      case SERVICE_AUTO_START:
      {
        szPath = _T("AUTO START");
        break;
      }
      case SERVICE_DEMAND_START:
      {
        szPath = _T("DEMAND START");
        break;
      }
      case SERVICE_DISABLED:
      {
        szPath = _T("DISABLED");
        break;
      }
      default:
      {
        szPath = _T("UNKNOWN");
      }
    }
    pNode.addAttr(L"Start", szPath);
  }
  RegCloseKey(hKey);
}
//
void GetMoreInformation(TElem &pNode, HDEVINFO hDevInfo, SP_DEVINFO_DATA spDevInfoData)
{
  CString strName(_T(""));
  LONG    nAddr;
  DWORD   nReqSize = 4;
  DWORD   const nMaxStrSize = 1024 * 4; 
  BOOL    bResult;
  TCHAR  *cpBuff;
  //
  if (SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_BUSNUMBER, NULL, (PBYTE)&nAddr, 4, &nReqSize))
  {
    strName.Format(_T("%X"), nAddr);
    pNode.addAttr(L"BUSNumber", strName);
  }
  else
  {
    NI_ASSERT(nReqSize == 4, "");
  }
  //
  if (SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_CAPABILITIES, NULL, (PBYTE)&nAddr, 4, &nReqSize))
  {
    if(nAddr)
    {
      CString sCapability(_T(""));
      if (nAddr & CM_DEVCAP_LOCKSUPPORTED)
        AddStringFlag(sCapability, "LockSupported");
      if (nAddr & CM_DEVCAP_EJECTSUPPORTED)
        AddStringFlag(sCapability, "EjectSupported");
      if (nAddr & CM_DEVCAP_REMOVABLE)
        AddStringFlag(sCapability, "Removable");
      if (nAddr & CM_DEVCAP_DOCKDEVICE)
        AddStringFlag(sCapability, "DockDevice");
      if (nAddr & CM_DEVCAP_UNIQUEID)
        AddStringFlag(sCapability, "UniqueID");
      if (nAddr & CM_DEVCAP_SILENTINSTALL)
        AddStringFlag(sCapability, "SilentInstall");
      if (nAddr & CM_DEVCAP_RAWDEVICEOK)
        AddStringFlag(sCapability, "RawDeviceOK");
      if (nAddr & CM_DEVCAP_SURPRISEREMOVALOK)
        AddStringFlag(sCapability, "SurpriseRemovalOK");
      if (nAddr & CM_DEVCAP_HARDWAREDISABLED)
        AddStringFlag(sCapability, "HardwareDisabled");
      if (nAddr & CM_DEVCAP_NONDYNAMIC)
        AddStringFlag(sCapability, "NonDynamic");
      pNode.addAttr(L"Capability", sCapability);
    }
  }
  else
  {
    NI_ASSERT(nReqSize == 4, "");
  }
  //
  if(SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData,
    SPDRP_CHARACTERISTICS, NULL, (PBYTE)&nAddr, 4, &nReqSize))
  {
    if (nAddr)
    {
      CString sCapability(_T(""));
      //
      if (nAddr & FILE_DEVICE_SECURE_OPEN)
        AddStringFlag(sCapability, "DEVICE_SECURE_OPEN");
      if (nAddr & FILE_FLOPPY_DISKETTE)
        AddStringFlag(sCapability, "FLOPPY_DISKETTE");
      if (nAddr & FILE_READ_ONLY_DEVICE)
        AddStringFlag(sCapability, "READ_ONLY_DEVICE");
      if (nAddr & FILE_REMOVABLE_MEDIA)
        AddStringFlag(sCapability, "REMOVABLE_MEDIA");
      if (nAddr & FILE_WRITE_ONCE_MEDIA)
        AddStringFlag(sCapability, "WRITE_ONCE_MEDIA");
      if (nAddr & FILE_REMOTE_DEVICE)
        AddStringFlag(sCapability,  "REMOTE_DEVICE");
      if (nAddr & FILE_DEVICE_IS_MOUNTED)
        AddStringFlag(sCapability, "DEVICE_IS_MOUNTED");
      if (nAddr & FILE_VIRTUAL_VOLUME)
        AddStringFlag(sCapability, "VIRTUAL_VOLUME");
      if (nAddr & FILE_AUTOGENERATED_DEVICE_NAME)
        AddStringFlag(sCapability, "AUTOGENERATED_DEVICE_NAME");
      pNode.addAttr(L"Characteristics", sCapability);
    }
  }
  else
  {
    NI_ASSERT(nReqSize == 4, "");
  }
  //
  if (SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_DEVTYPE, NULL,
      (PBYTE)&nAddr, 4, &nReqSize))
  {
    if(nAddr)
    {
      CString sCapability(_T(""));
      //
      if (nAddr == FILE_DEVICE_BEEP)
        AddStringFlag(sCapability, "DEVICE_BEEP");
      if (nAddr == FILE_DEVICE_CD_ROM)
        AddStringFlag(sCapability, "DEVICE_CD_ROM");
      if (nAddr == FILE_DEVICE_CD_ROM_FILE_SYSTEM)
        AddStringFlag(sCapability, "DEVICE_CD_ROM_FILE_SYSTEM");
      if (nAddr == FILE_DEVICE_CONTROLLER)
        AddStringFlag(sCapability, "DEVICE_CONTROLLER");
      if (nAddr == FILE_DEVICE_DATALINK)
        AddStringFlag(sCapability, "DEVICE_DATALINK");
      if (nAddr == FILE_DEVICE_DFS)
        AddStringFlag(sCapability, "DEVICE_DFS");
      if (nAddr == FILE_DEVICE_DISK)
        AddStringFlag(sCapability, "DEVICE_DISK");
      if (nAddr == FILE_DEVICE_DISK_FILE_SYSTEM)
        AddStringFlag(sCapability, "DEVICE_DISK_FILE_SYSTEM");
      if (nAddr == FILE_DEVICE_FILE_SYSTEM)
        AddStringFlag(sCapability, "DEVICE_FILE_SYSTEM");
      if (nAddr == FILE_DEVICE_INPORT_PORT)
        AddStringFlag(sCapability, "DEVICE_INPORT_PORT");
      if (nAddr == FILE_DEVICE_KEYBOARD)
        AddStringFlag(sCapability, "DEVICE_KEYBOARD");
      if (nAddr == FILE_DEVICE_MAILSLOT)
        AddStringFlag(sCapability, "DEVICE_MAILSLOT");
      if (nAddr == FILE_DEVICE_MIDI_IN)
        AddStringFlag(sCapability, "DEVICE_MIDI_IN");
      if (nAddr == FILE_DEVICE_MIDI_OUT)
        AddStringFlag(sCapability, "DEVICE_MIDI_OUT");
      if (nAddr == FILE_DEVICE_MOUSE)
        AddStringFlag(sCapability, "DEVICE_MOUSE");
      if (nAddr == FILE_DEVICE_MULTI_UNC_PROVIDER)
        AddStringFlag(sCapability, "DEVICE_MULTI_UNC_PROVIDER");
      if (nAddr == FILE_DEVICE_NAMED_PIPE)
        AddStringFlag(sCapability, "DEVICE_NAMED_PIPE");
      if (nAddr == FILE_DEVICE_NETWORK)
        AddStringFlag(sCapability, "DEVICE_NETWORK");
      if (nAddr == FILE_DEVICE_NETWORK_BROWSER)
        AddStringFlag(sCapability, "DEVICE_NETWORK_BROWSER");
      if (nAddr == FILE_DEVICE_NETWORK_FILE_SYSTEM)
        AddStringFlag(sCapability, "DEVICE_NETWORK_FILE_SYSTEM");
      if (nAddr == FILE_DEVICE_NULL)
        AddStringFlag(sCapability, "DEVICE_NULL");
      if (nAddr == FILE_DEVICE_PARALLEL_PORT)
        AddStringFlag(sCapability, "DEVICE_PARALLEL_PORT");
      if (nAddr == FILE_DEVICE_PHYSICAL_NETCARD)
        AddStringFlag(sCapability, "DEVICE_PHYSICAL_NETCARD");
      if (nAddr == FILE_DEVICE_PRINTER)
        AddStringFlag(sCapability, "DEVICE_PRINTER");
      if (nAddr == FILE_DEVICE_SCANNER)
        AddStringFlag(sCapability, "DEVICE_SCANNER");
      if (nAddr == FILE_DEVICE_SERIAL_MOUSE_PORT)
        AddStringFlag(sCapability, "DEVICE_SERIAL_MOUSE_PORT");
      if (nAddr == FILE_DEVICE_SERIAL_PORT)
        AddStringFlag(sCapability, "DEVICE_SERIAL_PORT");
      if (nAddr == FILE_DEVICE_SCREEN)
        AddStringFlag(sCapability, "DEVICE_SCREEN");
      if (nAddr == FILE_DEVICE_SOUND)
        AddStringFlag(sCapability, "DEVICE_SOUND");
      if (nAddr == FILE_DEVICE_STREAMS)
        AddStringFlag(sCapability, "DEVICE_STREAMS");
      if (nAddr == FILE_DEVICE_TAPE)
        AddStringFlag(sCapability, "DEVICE_TAPE");
      if (nAddr == FILE_DEVICE_TAPE_FILE_SYSTEM)
        AddStringFlag(sCapability, "DEVICE_TAPE_FILE_SYSTEM");
      if (nAddr == FILE_DEVICE_TRANSPORT)
        AddStringFlag(sCapability, "DEVICE_TRANSPORT");
      if (nAddr == FILE_DEVICE_UNKNOWN)
        AddStringFlag(sCapability, "DEVICE_UNKNOWN");
      if (nAddr == FILE_DEVICE_VIDEO)
        AddStringFlag(sCapability, "DEVICE_VIDEO");
      if (nAddr == FILE_DEVICE_VIRTUAL_DISK)
        AddStringFlag(sCapability, "DEVICE_VIRTUAL_DISK");
      if (nAddr == FILE_DEVICE_WAVE_IN)
        AddStringFlag(sCapability, "DEVICE_WAVE_IN");
      if (nAddr == FILE_DEVICE_WAVE_OUT)
        AddStringFlag(sCapability, "DEVICE_WAVE_OUT");
      if (nAddr == FILE_DEVICE_8042_PORT)
        AddStringFlag(sCapability, "DEVICE_8042_PORT");
      if (nAddr == FILE_DEVICE_NETWORK_REDIRECTOR)
        AddStringFlag(sCapability, "DEVICE_NETWORK_REDIRECTOR");
      if (nAddr == FILE_DEVICE_BATTERY)
        AddStringFlag(sCapability, "DEVICE_BATTERY");
      if (nAddr == FILE_DEVICE_BUS_EXTENDER)
        AddStringFlag(sCapability, "DEVICE_BUS_EXTENDER");
      if (nAddr == FILE_DEVICE_MODEM)
        AddStringFlag(sCapability, "DEVICE_MODEM");
      if (nAddr == FILE_DEVICE_VDM)
        AddStringFlag(sCapability, "DEVICE_VDM");
      if (nAddr == FILE_DEVICE_MASS_STORAGE)
        AddStringFlag(sCapability, "DEVICE_MASS_STORAGE");
      if (nAddr == FILE_DEVICE_SMB)
        AddStringFlag(sCapability, "DEVICE_SMB");
      if (nAddr == FILE_DEVICE_KS)
        AddStringFlag(sCapability, "DEVICE_KS");
      if (nAddr == FILE_DEVICE_CHANGER)
        AddStringFlag(sCapability, "DEVICE_CHANGER");
      if (nAddr == FILE_DEVICE_SMARTCARD)
        AddStringFlag(sCapability, "DEVICE_SMARTCARD");
      if (nAddr == FILE_DEVICE_ACPI)
        AddStringFlag(sCapability, "DEVICE_ACPI");
      if (nAddr == FILE_DEVICE_DVD)
        AddStringFlag(sCapability, "FILE_DEVICE_DVD");
      if (nAddr == FILE_DEVICE_FULLSCREEN_VIDEO)
        AddStringFlag(sCapability, "DEVICE_FULLSCREEN_VIDEO");
      if (nAddr == FILE_DEVICE_DFS_FILE_SYSTEM)
        AddStringFlag(sCapability, "DEVICE_DFS_FILE_SYSTEM");
      if (nAddr == FILE_DEVICE_DFS_VOLUME)
        AddStringFlag(sCapability, "DEVICE_DFS_VOLUME");
      if (nAddr == FILE_DEVICE_SERENUM)
        AddStringFlag(sCapability, "DEVICE_SERENUM");
      if (nAddr == FILE_DEVICE_TERMSRV)
        AddStringFlag(sCapability, "DEVICE_TERMSRV");
      if (nAddr == FILE_DEVICE_KSEC)
        AddStringFlag(sCapability, "DEVICE_KSEC");
      pNode.addAttr(L"Device_Type", sCapability);
    }
  }
  else
  {
    NI_ASSERT(nReqSize == 4, "");
  }
  //
  bResult = SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData,
    SPDRP_DRIVER, NULL, (PBYTE)strName.GetBuffer(nMaxStrSize), sizeof(TCHAR) * nMaxStrSize, NULL);
  strName.ReleaseBuffer();
  if(bResult)
  {
    pNode.addAttr(L"Driver", strName);
  }
  //
  bResult = SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_ENUMERATOR_NAME,
    NULL,(PBYTE)strName.GetBuffer(nMaxStrSize), sizeof(TCHAR) * nMaxStrSize,  NULL);
  strName.ReleaseBuffer();
  if(bResult)
  {
    pNode.addAttr(L"Enumerator", strName);
  }
  //
  bResult = SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData,
    SPDRP_HARDWAREID, NULL, (PBYTE)(cpBuff = strName.GetBuffer(nMaxStrSize)), sizeof(TCHAR) * nMaxStrSize, NULL);
  if(bResult)
  {
    CString sCapability(_T(""));
    TCHAR *p = cpBuff;
    //
    while(*p)
    {
      AddStringFlag(sCapability, p);
      p = _tcschr(p, _T('\0'));
      p++;
    }
    pNode.addAttr(L"Hardware_ID", sCapability);
  }
  strName.ReleaseBuffer();

  //
  bResult = SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_LOCATION_INFORMATION,
    NULL, (PBYTE)strName.GetBuffer(nMaxStrSize), sizeof(TCHAR) * nMaxStrSize, NULL);
  strName.ReleaseBuffer();
  if(bResult)
  {
    pNode.addAttr(L"Local_Information", strName);
  }
  //
  bResult = SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_LOWERFILTERS,
    NULL, (PBYTE)strName.GetBuffer(nMaxStrSize), sizeof(TCHAR) * nMaxStrSize, NULL);
  strName.ReleaseBuffer();
  if(bResult)
  {
    pNode.addAttr(L"Lower_Filter", strName);
  }
  //
  bResult = SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData,
    SPDRP_UPPERFILTERS, NULL, (PBYTE)strName.GetBuffer(nMaxStrSize), sizeof(TCHAR) * nMaxStrSize, NULL);
  strName.ReleaseBuffer();
  if(bResult)
  {
    pNode.addAttr(L"Upper_Filter", strName);
  }
  //
  bResult = SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
    NULL, (PBYTE)strName.GetBuffer(nMaxStrSize), sizeof(TCHAR) * nMaxStrSize, NULL);
  strName.ReleaseBuffer();
  if(bResult)
  {
    pNode.addAttr(L"Physical_Device_Object_Name", strName);
  }
  //
  strName = _T("");
  cpBuff = strName.GetBuffer(nMaxStrSize);
  memset(cpBuff, 0, sizeof(TCHAR) * nMaxStrSize);
  bResult = SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData,
    SPDRP_SERVICE, NULL, (PBYTE)cpBuff, sizeof(TCHAR) * nMaxStrSize, NULL);
  if(bResult)
  {
    CString sCapability(_T(""));
    TCHAR *p = cpBuff;

    //
    if(*p)
      GetDriverName(pNode, cpBuff);
    while (*p)
    {
      AddStringFlag(sCapability, p);
      p = _tcschr(p, _T('\0'));
      p++;
      while(_tcschr(p, _T('\\')))
      {
        p = _tcschr(p, _T('\0'));
        p++;
      }
    }
    pNode.addAttr(L"Service_Name", sCapability);
  }
  strName.ReleaseBuffer();
}
void GetMemoryResource(MEM_DES* pMemDes, const ULONG ulSize, TElem &pNode)
{
  TCHAR szBuf[1024] = {0};
  short nLoop       = 0;
  CString strPar(_T("Value"));
  CString strDer(_T(""));
  USES_CONVERSION;

  pNode.addAttr(L"Name", L"Memory Range");
  //
  _stprintf_s(szBuf, 1024, _T("%08X - "), pMemDes->MD_Alloc_Base);
  _stprintf_s(szBuf + _tcslen(szBuf), 1024 - _tcslen(szBuf), _T("%08X"), pMemDes->MD_Alloc_End);
  pNode.addAttr(A2W(strPar), szBuf);
  //
  if (pMemDes->MD_Count)
  {
    for (nLoop = 0; nLoop < (short)(ulSize - 
      (LONG)(sizeof(MEM_DES) / pMemDes->MD_Type)); nLoop++)
    {
      MEM_RANGE *pMemRange = (MEM_RANGE*)(pMemDes + 1);// + pMemDes->MD_Type);
      if (pMemRange->MR_Min != 0 && pMemRange->MR_Max != 0 &&
        (pMemRange->MR_Min < pMemRange->MR_Max))
      {
        _stprintf_s(szBuf, 1024, _T("%08X - "), pMemRange->MR_Min);
        _stprintf_s(szBuf + _tcslen(szBuf), 1024 - _tcslen(szBuf), _T("%08X"), pMemRange->MR_Max);
        strDer.Format(_T("%s_%d"), (TCHAR const *)strPar, nLoop);
        pNode.addAttr(A2W(strDer), szBuf);
      }
    }
  }
}
//
void GetIOResource(IO_DES *pIODes, const ULONG ulSize, TElem &pNode)
{
  TCHAR szBuf[1024] = {0};
  short nLoop       = 0;
  CString strPar(_T("Value"));
  CString strDer(_T(""));
  USES_CONVERSION;

  pNode.addAttr(L"Name", L"IO Range");
  //
  _stprintf_s(szBuf, 1024, _T("%04X - "), pIODes->IOD_Alloc_Base);
  _stprintf_s(szBuf + _tcslen(szBuf), 1024 - _tcslen(szBuf), _T("%04X"), pIODes->IOD_Alloc_End);
  //
  pNode.addAttr(A2W(strPar), szBuf);
  //
  if (pIODes->IOD_Count)
  {
    for (nLoop = 0; nLoop < (short)(ulSize -
      (ULONG)(sizeof(IO_DES) / pIODes->IOD_Type)); nLoop++)
    {
      IO_RANGE *pIORange = (IO_RANGE*)(pIODes + 1); // + (wLoop * pIODes->IOD_Type));
      if (pIORange->IOR_Min != 0 && pIORange->IOR_Max != 0 &&
        (pIORange->IOR_Min < pIORange->IOR_Max))
      {
        _stprintf_s(szBuf, 1024, _T("%04X - "), pIORange->IOR_Min);
        _stprintf_s(szBuf + _tcslen(szBuf), 1024 - _tcslen(szBuf), _T("%04X"), pIORange->IOR_Max);
        strDer.Format(_T("%s_%d"), (TCHAR const *)strPar, nLoop);
        pNode.addAttr(A2W(strDer), szBuf);
      }
    }
  }
}
//
void GetDMAResource(DMA_DES* pDMADes, const ULONG ulSize, TElem &pNode)
{
  TCHAR szBuf[1024] = {0};
  short nLoop       = 0;
  CString strPar(_T("Value"));
  CString strDer(_T(""));
  USES_CONVERSION;

  pNode.addAttr(L"Name", L"DMA");
  //
  _stprintf_s(szBuf, 1024, _T("%02d"), pDMADes->DD_Alloc_Chan);
  pNode.addAttr(A2W(strPar), szBuf);
  //
  if (pDMADes->DD_Count)
  {
    for (nLoop = 0; nLoop < (short)(ulSize -
      (ULONG)(sizeof(DMA_DES) / pDMADes->DD_Type)); nLoop++)
    {
      DMA_RANGE *pDMARange = (DMA_RANGE*)(pDMADes + 1); // + (wLoop * pIODes->IOD_Type));
      if (pDMARange->DR_Min != 0 && pDMARange->DR_Max != 0 &&
        (pDMARange->DR_Min < pDMARange->DR_Max))
      {
        _stprintf_s(szBuf, 1024, _T("%02d - "), pDMARange->DR_Min);
        _stprintf_s(szBuf + _tcslen(szBuf), 1024 - _tcslen(szBuf), _T("%02d"), pDMARange->DR_Max);
        strDer.Format(_T("%s_%d"), (TCHAR const *)strPar, nLoop);
        pNode.addAttr(A2W(strDer), szBuf);
      }
    }
  }
}
//
void GetIRQResource(IRQ_DES* pIRQDes, const ULONG ulSize, TElem &pNode)
{
  TCHAR szBuf[1024] = {0};
  short nLoop       = 0;
  CString strPar(_T("Value"));
  CString strDer(_T(""));
  USES_CONVERSION;

  pNode.addAttr(L"Name", L"IRQ");
  //
  _stprintf_s(szBuf, 1024, _T("%02d"), pIRQDes->IRQD_Alloc_Num);
  pNode.addAttr(A2W(strPar), szBuf);
  //
  if (pIRQDes->IRQD_Count)
  {
    for (nLoop = 0; nLoop < (short)(ulSize - (ULONG)(sizeof(IRQ_DES) / pIRQDes->IRQD_Type)); nLoop++)
    {
      IRQ_RANGE *pIRQRange = (IRQ_RANGE*)(pIRQDes + 1); // + (wLoop * pIODes->IOD_Type));
      if (pIRQRange->IRQR_Min != 0 && pIRQRange->IRQR_Max != 0 &&
        (pIRQRange->IRQR_Min < pIRQRange->IRQR_Max))
      {
        _stprintf_s(szBuf, 1024, _T("%02d - "), pIRQRange->IRQR_Min);
        _stprintf_s(szBuf + _tcslen(szBuf), 1024 - _tcslen(szBuf), _T("%02d"), pIRQRange->IRQR_Max);
        strDer.Format(_T("%s_%d"), (TCHAR const *)strPar, nLoop);
        pNode.addAttr(A2W(strDer), szBuf);
      }
    }
  }
}

void FindSpecResource(const DEVINST DevInst, const DWORD dwResType, TElem &pNode, CComPtr<IXMLDOMDocument> &pDoc)
{
  TCHAR *pBuf  = 0L;
  short wHeaderSize;
  ULONG nSize = sizeof(TCHAR) * 2048 - 1;
  //
  CONFIGRET cmRet;
  LOG_CONF  firstLogConf;
  LOG_CONF  nextLogConf;
  RES_DES   rdPrevResDes;
  //
  switch(dwResType)
  {
    case ResType_Mem:
    {
      wHeaderSize = sizeof(MEM_DES);
      break;
    }
    //
    case ResType_IO:
    {
      wHeaderSize = sizeof(IO_DES);
      break;
    }
    //
    case ResType_DMA:
    {
      wHeaderSize = sizeof(DMA_DES);
      break;
    }
    //
    case ResType_IRQ: 
    {
      wHeaderSize = sizeof(IRQ_DES);
      break;
    }
  }
  //
  cmRet = CM_Get_First_Log_Conf(&firstLogConf, DevInst, ALLOC_LOG_CONF);
  if (cmRet != CR_SUCCESS)
  {
    cmRet = CM_Get_First_Log_Conf(&firstLogConf, DevInst, BOOT_LOG_CONF);
    if (cmRet != CR_SUCCESS)
      return;
  }  
  cmRet = CM_Get_Next_Res_Des(&nextLogConf, firstLogConf, dwResType, 0L, 0L);
  if (cmRet != CR_SUCCESS)
  {
    CM_Free_Res_Des_Handle(firstLogConf);
    return;
  }
  //
  while(true)
  {
    //
    nSize = 0;
    cmRet = CM_Get_Res_Des_Data_Size(&nSize, nextLogConf, 0L);
    if (cmRet != CR_SUCCESS)
    {
      CM_Free_Res_Des_Handle(nextLogConf);
      break;
    }
    //
    pBuf = (TCHAR *)LocalAlloc(LPTR, max<ULONG>(nSize, sizeof(TCHAR) * 2048));
    if(!pBuf)
    {
      NI_ASSERT(false, "");
      CM_Free_Res_Des_Handle(nextLogConf);
      break;
    }
    //
    cmRet = CM_Get_Res_Des_Data(nextLogConf, pBuf, nSize, 0L);
    if (cmRet != CR_SUCCESS)
    {
      CM_Free_Res_Des_Handle(nextLogConf);
      LocalFree(pBuf);
      break;
    }
    //
    TElem pResNode = pNode.createChildNode(pDoc, L"Resource");
    switch(dwResType)
    {
      case ResType_Mem:
      {
        GetMemoryResource((MEM_DES*)pBuf, nSize, pResNode);
        break;
      }
      case ResType_IO:
      {
        GetIOResource((IO_DES*)pBuf, nSize, pResNode);
        break;
      }
      case ResType_DMA:
      {
        GetDMAResource((DMA_DES*)pBuf, nSize, pResNode);
        break;
      }
    case ResType_IRQ: 
      {
        GetIRQResource((IRQ_DES*)pBuf, nSize, pResNode);
        break;
      }
    }
    rdPrevResDes = 0;
    cmRet = CM_Get_Next_Res_Des(&rdPrevResDes, nextLogConf, dwResType, 0L, 0L);
    LocalFree(pBuf);
    if (cmRet != CR_SUCCESS)
      break;
    else
    {
      CM_Free_Res_Des_Handle(nextLogConf);
      nextLogConf = rdPrevResDes;
    }
  }
  CM_Free_Res_Des_Handle(nextLogConf);
}

void GetOtherInfo(CComPtr<IXMLDOMDocument> &pDoc, TElem &pNode, SP_DEVINFO_DATA &devInfoData, HDEVINFO hDevInfo)
{
  SP_DRVINFO_DATA         spDrvInfoData      = {0};
  PSP_DRVINFO_DETAIL_DATA spDrvInfoDetail    = NULL;
  //TCHAR                   szHardware[128]    = {0};
  DWORD                   nRequiredSize;
  short                   nIdx;
  //
  GetMoreInformation(pNode, hDevInfo, devInfoData);
  // Show Resource Information  
  for (nIdx = ResType_Mem; nIdx <= ResType_IRQ; nIdx++)
    FindSpecResource(devInfoData.DevInst, nIdx, pNode, pDoc);
  //
  if (FALSE == SetupDiBuildDriverInfoList(hDevInfo, &devInfoData, SPDIT_COMPATDRIVER))
  {
    NI_ASSERT(false, "");
  }
  nIdx = 0;
  while (1)
  {
    spDrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiEnumDriverInfo(hDevInfo, &devInfoData, SPDIT_COMPATDRIVER, nIdx++, &spDrvInfoData))
    {
      //
      nRequiredSize = 0;
      if(SetupDiGetDriverInfoDetail(hDevInfo, &devInfoData, &spDrvInfoData, NULL, 0, &nRequiredSize) == TRUE && nRequiredSize != 0)
      {
        spDrvInfoDetail = (PSP_DRVINFO_DETAIL_DATA)LocalAlloc(LPTR, nRequiredSize);
        spDrvInfoDetail->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if(SetupDiGetDriverInfoDetail(hDevInfo, &devInfoData, &spDrvInfoData, spDrvInfoDetail, nRequiredSize, &nRequiredSize))
        {
          SYSTEMTIME sysTime   = {0};
          TCHAR      szTmp[64] = {0};
          //
          CString sHdwIDs(_T(""));
          TCHAR *p = spDrvInfoDetail->HardwareID;
          //
          while(*p)
          {
            AddStringFlag(sHdwIDs, p);
            p = _tcschr(p, _T('\0'));
            p++;
          }
          pNode.addAttr(L"Hardware", sHdwIDs);
          pNode.addAttr(L"MfgName", spDrvInfoData.MfgName);
          pNode.addAttr(L"ProviderName", spDrvInfoData.ProviderName);
          pNode.addAttr(L"Description", spDrvInfoData.Description);
          FileTimeToSystemTime(&spDrvInfoData.DriverDate, &sysTime);
          _stprintf_s(szTmp, 63, _T("%02d/%02d/%04d"), sysTime.wMonth,
            sysTime.wDay, sysTime.wYear);
          pNode.addAttr(L"DriverDate", szTmp);
          pNode.addAttr(L"SectionName", spDrvInfoDetail->SectionName);
          pNode.addAttr(L"InfFileName", spDrvInfoDetail->InfFileName);
        }
        else
        {
          NI_ASSERT(ERROR_INSUFFICIENT_BUFFER != GetLastError(), "");
          //RtlZeroMemory(szHardware, sizeof(TCHAR) * 128);
        }
        LocalFree(spDrvInfoDetail);
      }
    }
    else
    {
      DWORD dwError = GetLastError();
      //
      if(dwError != ERROR_NO_MORE_ITEMS)
      {
        NI_ASSERT(false, "");
      }
      break;
    }
    SetupDiDestroyDriverInfoList(hDevInfo, &devInfoData, SPDIT_COMPATDRIVER);
  }
}

/**
@brief    Fill device information node

@param    pNode node to be filled
@param    pDoc document for subnode creation
@author   Earnol
*/
void SystemReport::FillDevicesNode(NBSU::TElem &pNode, CComPtr<IXMLDOMDocument> &pDoc)
{
  HDEVINFO        hDevInfo         = 0L;
  SP_DEVINFO_DATA spDevInfoData    = {0};
  DWORD           nIndex           = 0;

  hDevInfo = SetupDiGetClassDevs(0L, 0L, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES | DIGCF_PROFILE);
  if(hDevInfo == INVALID_HANDLE_VALUE)
  {
    return;
  }
  spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

  while(true)
  {
    if(FALSE != SetupDiEnumDeviceInfo(hDevInfo, nIndex, &spDevInfoData))
    {
      TCHAR szBuf[MAX_PATH + 1] = {0};
      //
      if(FALSE == SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_CLASS, //SPDRP_DEVICEDESC,
        NULL, (PBYTE)szBuf, sizeof(TCHAR) * MAX_PATH, NULL))
      {
        nIndex++;
        continue;
      }
      //
      {
        TCHAR                  szName[MAX_PATH + 1]      = {0};
        TCHAR                  szID[LINE_LEN + 1]  = {0};
        CString                szPath;
        DWORD                  dwRequireSize;
        //
        if(!SetupDiGetClassDescription(&spDevInfoData.ClassGuid, szBuf, MAX_PATH, &dwRequireSize))
        {
          nIndex++;
          continue;
        }
        TElem pDevice = pNode.createChildNode(pDoc, L"Device");
        pDevice.addAttr(L"DeviceClassDesc", szBuf);
        GetDeviceInstanceID(hDevInfo, &spDevInfoData, szID);
        pDevice.addAttr(L"InstanceID", szID);
        GetDeviceInterfaceInfo(hDevInfo, spDevInfoData, szPath);
        pDevice.addAttr(L"InterfaceInfo", szPath);
        //
        if(SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData, SPDRP_FRIENDLYNAME,
          0L, (PBYTE)szName, sizeof(TCHAR) * MAX_PATH, 0))
        {
          TElem pDeviceProp = pDevice.createChildNode(pDoc, L"DeviceProperties");
          pDeviceProp.addAttr(L"Name", szName);
          GetOtherInfo(pDoc, pDeviceProp, spDevInfoData, hDevInfo);
        }
        else if (SetupDiGetDeviceRegistryProperty(hDevInfo, &spDevInfoData,
          SPDRP_DEVICEDESC,  0L, (PBYTE)szName, sizeof(TCHAR) * MAX_PATH, 0))
        {
          TElem pDeviceProp = pDevice.createChildNode(pDoc, L"DeviceProperties");
          pDeviceProp.addAttr(L"Name", szName);
          GetOtherInfo(pDoc, pDeviceProp, spDevInfoData, hDevInfo);
          
        }
      }
    }
    else
      break;
    nIndex++;
  }
  CString szBuf;
  if (GetFirmwareEnvironmentVariable("Lang", "8BE4DF61-93CA-11d2-AA0D-00E098032B8C", szBuf.GetBuffer(127), 127))
  {
    szBuf.ReleaseBuffer();
    TElem pVariables = pNode.createChildNode(pDoc, L"EFI Variables");
    pVariables.addAttr(L"Lang", szBuf);
  }
  else
  {
    szBuf.ReleaseBuffer();
  }

  SetupDiDestroyDeviceInfoList(hDevInfo);
  return;
}  // end of NBSU::FillDevicesNode

/**
  @brief    Fill memory information node

  @param    pNode node to be filled
  @param    pDoc document for subnode creation
  @author   Earnol
*/
void SystemReport::FillMemoryNode(TElem &pNode, CComPtr<IXMLDOMDocument> &pDoc)
{
  WCHAR const *physicalName                   = L"Physical"         ;
  WCHAR const *pageName                       = L"PageFile"         ;
  WCHAR const *virtualName                    = L"Virtual"          ;
  //WCHAR const *extVirtualName                 = L"Extended Virtual" ;
  WCHAR const *loadName                       = L"CurrentLoad"      ;
  WCHAR const *totalName                      = L"Total"            ;
  WCHAR const *availName                      = L"Available"        ;
  MEMORYSTATUS memStatus;
  CString memLoadStr(_T(""));
  
  //take form system
  GlobalMemoryStatus(&memStatus);

  TElem pPhysical = pNode.createChildNode(pDoc, physicalName);
  pPhysical.addAttr(totalName, (DWORD)memStatus.dwTotalPhys);
  pPhysical.addAttr(availName, (DWORD)memStatus.dwAvailPhys);

  TElem pVirtual = pNode.createChildNode(pDoc, virtualName);
  pVirtual.addAttr(totalName, (DWORD)memStatus.dwTotalVirtual);
  pVirtual.addAttr(availName, (DWORD)memStatus.dwAvailVirtual);

  TElem pPageFile = pNode.createChildNode(pDoc, pageName);
  pPageFile.addAttr(totalName, (DWORD)memStatus.dwTotalPageFile);
  pPageFile.addAttr(availName, (DWORD)memStatus.dwAvailPageFile);

  memLoadStr.Format(_T("%d%s"), memStatus.dwMemoryLoad, _T("%"));
  pNode.addAttr(loadName, memLoadStr);

  return;
} // end of SystemReport::FillMemoryNode

/**
@brief    Fill node for single module

@return   Loaded modules information node
@param    pNode node to be filled
@param    pDoc to create subnodes in
@author   Earnol
*/
void SystemReport::FillModuleNode(TElem &pNode, CComPtr<IXMLDOMDocument> &pDoc, MINIDUMP_MODULE_CALLBACK const *pItem)
{
  WCHAR const *fullPath                    = L"FullPath"      ;
  WCHAR const *baseAddrName                = L"BaseAddress"   ;
  WCHAR const *sizeName                    = L"Size"          ;
  WCHAR const *timeStampName               = L"TimeStamp"     ;
  WCHAR const *fileVerName                 = L"FileVersion"   ;
  WCHAR const *prodVerName                 = L"ProductVersion";

  // Set full path
  pNode.addAttr(fullPath, pItem->FullPath);

  // Set base address
  TCHAR buffer[_MAX_PATH];
  _stprintf_s(buffer, _MAX_PATH - 2, _T("0x%08x"), pItem->BaseOfImage);
  pNode.addAttr(baseAddrName, buffer);

  // Set module size
  _stprintf_s(buffer, _MAX_PATH - 2, _T("0x%08x"), pItem->SizeOfImage);
  pNode.addAttr(sizeName, buffer);

  // Set timestamp
  FILETIME    ft = GetLastWriteFileTime(wstring(pItem->FullPath));
  SYSTEMTIME  st = {0};
  FileTimeToSystemTime(&ft, &st);
  _stprintf_s(buffer, _MAX_PATH - 2, _T("%02u/%02u/%04u %02u:%02u:%02u"), 
    st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
  pNode.addAttr(timeStampName, buffer);

  // Set file version
  _stprintf_s(buffer, _MAX_PATH - 2, _T("%d.%d.%d.%d"), 
    HIWORD(pItem->VersionInfo.dwFileVersionMS),
    LOWORD(pItem->VersionInfo.dwFileVersionMS),
    HIWORD(pItem->VersionInfo.dwFileVersionLS),
    LOWORD(pItem->VersionInfo.dwFileVersionLS));
  pNode.addAttr(fileVerName, buffer);

  // Set product version
  _stprintf_s(buffer, _MAX_PATH - 2, _T("%d.%d.%d.%d"), 
    HIWORD(pItem->VersionInfo.dwProductVersionMS),
    LOWORD(pItem->VersionInfo.dwProductVersionMS),
    HIWORD(pItem->VersionInfo.dwProductVersionLS),
    LOWORD(pItem->VersionInfo.dwProductVersionLS));
  pNode.addAttr(prodVerName, buffer);

  return;
}

/**
  @brief    Fill modules Node

  @return   Loaded modules information node
  @param    pNode node to be filled
  @param    pDoc to create subnodes in
  @author   Earnol
*/
void SystemReport::FillModulesNode(TElem &pNode, CComPtr<IXMLDOMDocument> &pDoc)
{
   WCHAR const *nodeName2                   = L"Module"        ;

   // Add module information
   node = start.next;
   while(node)
   {
      // Create module node
      TElem pNode2 = pNode.createChildNode(pDoc, nodeName2);

      FillModuleNode(pNode2, pDoc, &node->item);

      //to next
      node = node->next;
   }
   return;
}

// *******************************************************************
// functions 
}
//#pragma warning (pop)

