МЕХАНИЗМЫ ВНУТРИ-КЛАСТЕРНОЙ РАБОТЫ С ПАРТИЯМИ (группами юзеров)
-------------------------------------------------------------------------------------------------

Для реализации в социальном кластере работы с партиями (party invite, accept/decline, kick/disband, и go всей группой в матчмейкинг) придется использовать два новых механизма: клиентский "отложенный поллинг" и peer-messaging между рабочими серверами.

1. Отложенный поллинг

Чтобы не долбать сервер непрерывными частыми пингами ("а меня никто там не пригласил в группу?", "а кто-нибудь ответил на мой инвайт?" и т.п.), предлагается использовать механизм "отложенного поллинга": 
- клиент посылает на сервер ping с таймаутом порядка 20-30 секунд
- если серверу нечего сообщить клиенту (нет pending событий), сервер не отвечает на этот запрос (вешает таймаут порядка 15-20 секунд); 
  если есть pending события, сервер отвечает сразу.
- получив ответ на ping (и обработав полученные события), клиент посылает новый ping
- если за время ожидания (клиент ждет ответа на ping) сервер доставляет для данного юзера какое-нибудь новое событие, он кладет событие в pending и "будит" ждущий ping-запрос (в результате чего клиент сразу получает событие, в ответе на ping).

Прототипчик такого механизма на соц.сервере уже есть, опробован успешно.


2. Peer-messaging

Поскольку в production соц.кластере может быть порядка 10-100 рабочих серверов, юзеры, создающие группу, будут часто находиться на разных серверах.

Поэтому все механизмы обработки/пересылки внутри-кластерных party-команд должны работать независимо от того, на одном или на разных work-серверах находятся юзеры.
Созданием и поддержанием партий будет заниматься выделенный party server; PartyContext создается только на нем, и все party-события пересылаются через него.
ПЛЮСЫ: 
- заметно легче становится "миграция мастера" (PartyServer перещелкивает на следующего, передавать по сети "эстафетную палочку" is_master не надо)
- уменьшается общее кол-во p2p-соединений в большом кластере (на 50 машинах это уже 50 соединений PeerWS<->PartyServer вместо 2.500 P2P-соединений)
МИНУСЫ:
- лишний посредник при передаче
- single point of failure (PartyServer отвалился или перегрузили запросами => больше никаких никому партий)


3. Контекст партии

Контекст партии будет создаваться при первом же событии party invite (юзер, не имеющий партии, отправляет инвайт другому юзеру).
При создании контекста PersonServer выдает ему уникальный глобальный party_id.
Все последующие запросы помечаются этим party_id.

Pending invites помещаются в соотв. коллекцию, откуда потом прибиваются по получению accept/decline или по таймауту.

-------------------------------------------------------------------------------------------------

PartyContext {
	party_id: INT64
	is_master: 0/1 // признак того, что данный контекст "хозяйский" (только он может рассылать invites, делать kick и go)
	members:[ auid, auid, ... ] // первый по списку - всегда мастер
	pending_invites: { // если остался последний member и нет висящих инвайтов, партия прибивается
		<auid>: timestamp_sent
	}
}

Контексты партий будет лежать в хэше PersonServer.parties[party_id]
Записи с данными пользователей (uid, server, personal_data:nick/photo/...) будет лежать в хэше PersonServer.users[auid]
	

4. Список party-команд (приблизительный)

С учетом централизации работы с партиями (на PersonServer) рабочие сервера (WS) становятся просто тупыми посредниками между клиентом и PersonServer.
Все команды для работы с партиями они принимают от клиента в виде action=party&cmd=<command>&<..more_params..> и тупо форвардят в том же виде на PersonServer (возможно, добавляя необходимые реквизиты типа auid, server_name и т.п.)
Аналогично, ответы PersonServer принимаются в виде action=server_party&cmd=<command>&.. и отдаются клиентам в ответ на их long-polling пинги.

Максимум чем может позаниматься WS - это фильтрация спама (если PersonServer присылает гневный ответ, можем заблокировать соотв. юзеру доступ к PersonServer на некоторое время).

Персональную инфу (из соц.аггрегатора) тоже будет присылать в своих командах PersonServer; WS будет только форвардить ее на клиент.

=========================================================================================================================================================


Для иллюстрации работы peer-механизмов рассылки команд см. рисунок http://devjira.nivalnetwork.com/secure/attachment/41068/PARTY_Invite-Accept-Add.jpg

-------------------------------------------------------------------------------------------------
PING (регулярно отсылаем на сервер; сервер отвечает по таймауту 15 сек. или когда "есть чо")

[запрос] -
[ответ]
	"party": {
		"party_id":INT64
		"members": [
			{ ..первым по списку всегда идет party leader.. },
		]
	}
	"party_events": [
		{ "cmd":<command>, "ts":<timestamp>, ... прочие параметры },
	]


-------------------------------------------------------------------------------------------------
PARTY_INVITE

принимаем либо от мастера неполной группы, len(members) + len(pending_invites) < MAX_GROUP_MEMBERS, 
либо от юзера, не имеющего группы (!party_uid)

[запрос] 
	? invite_login:STRING // из списка друзей, получаемого из аггрегатора, будем каким-то образом доставать кластерный login, это проблема сервера и persistent
	? members: {...} // думаю, имеет смысл сразу добавить в peer-запрос и/или клиентский запрос весь список members
[ответ]
	party_id:INT64
	error:user not logged
[приходит приглашаемому юзеру в виде]
	{ "cmd":"invite", "user":<STRING nick>, "uid":INT64, "server":STRING, "ts":<INT timestamp> }
[отложенный ответ (через PING)]
	{ "cmd":"accept", "user":<STRING nick>, "uid":INT64, "server":STRING, "ts":<INT timestamp> }
	{ "cmd":"decline", "user":<STRING nick>, "uid":INT64, "server":STRING, "ts":<INT timestamp>, возможен также "error":"user not logged"}
	
// !! по получению peer-сервером приглашаемого -- сразу заводим локальный контекст группы (возможно, пустой), чисто для добавления туда pending_invite
// - нюанс: если мы мастер пустой группы, то нас можно приглашать в другую группу (своя при этом грохнется, как только нам придет peer add в чужую группу);
//		    (это нужно для того чтобы два соло юзера, одновременно приглашающих друг друга, могли успешно создать группу)


-------------------------------------------------------------------------------------------------
PARTY_ACCEPT

принимаем при наличии непротухшего приглашения (pending_invites?..)

[запрос] 
	party_id:INT64	
[ответ] -
[приходит пригласившему юзеру в виде]
	{ "cmd":"accept", "party_id":INT64, user":<STRING nick>, "uid":INT64, "server":STRING, "ts":<INT timestamp> }

// !! по ответу нужно занести на <WS приглашенного юзера> полную копию контекста партии (принести список юзеров)

-------------------------------------------------------------------------------------------------
PARTY_DECLINE

принимаем при наличии непротухшего приглашения (pending_invites?..)

[запрос] 
	party_id:INT64
	user_msg:STRING
[ответ]
[приходит пригласившему юзеру в виде]
	{ "cmd":"decline", "user":<STRING nick>, "uid":INT64, "server":STRING, "ts":<INT timestamp>, "reason":<STRING user_msg or error> }
	
// по decline убираем из master context соотв. pending invite

-------------------------------------------------------------------------------------------------
PARTY_KICK

принимаем только от мастера группы, target_uid должен быть в партии 

[запрос] 
	party_id:INT64
	target_uid:INT64
	user_msg:STRING
[приходит таргет-юзеру в виде]
	{ "cmd":"kick", "user":<STRING nick>, "uid":INT64, "server":STRING, "ts":<INT timestamp>, "reason":<STRING user_msg or error> }

-------------------------------------------------------------------------------------------------
PARTY_LEAVE

может приходить пользовательский (юзер сам кликнул LEAVE PARTY) и технический (например при logout юзера с соц.сервера)

[запрос] 
	party_id:INT64
	user_msg:STRING
[приходит юзерам в виде]
	{ "cmd":"leave", "user":<STRING nick>, "uid":INT64, "server":STRING, "ts":<INT timestamp>, "reason":<STRING user_msg or error> }


-------------------------------------------------------------------------------------------------
PARTY_GO

принимаем только от мастера группы, 

[запрос] 
	party_id:INT64
	? прочие параметры аналогичны mm_add ?..
	
// по получению мастер-сервером этого запроса всем членам группы рассылается событие "party_go", по которому соотв. рабочие сервера генерируют команды mm_add для группового перехода в матчмейкинг.
// каждый запрос mm_add будет содержать party_id и список uid-ов party.members; 
//  если матчмейкер кого-то не досчитается, он обломит добавление группы в матчмейкинг и вернет ошибку с каким-либо новым кодом (progress=201?)

